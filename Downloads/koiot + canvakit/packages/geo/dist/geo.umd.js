(function(x,z){typeof exports=="object"&&typeof module<"u"?z(exports):typeof define=="function"&&define.amd?define(["exports"],z):(x=typeof globalThis<"u"?globalThis:x||self,z(x.geo={}))})(this,function(x){"use strict";var Sn=Object.defineProperty;var Cn=(x,z,N)=>z in x?Sn(x,z,{enumerable:!0,configurable:!0,writable:!0,value:N}):x[z]=N;var X=(x,z,N)=>(Cn(x,typeof z!="symbol"?z+"":z,N),N);class z{constructor(t=1,e=0,s=0,i=1,o=0,r=0){X(this,"a");X(this,"b");X(this,"c");X(this,"d");X(this,"tx");X(this,"ty");this.a=t,this.b=e,this.c=s,this.d=i,this.tx=o,this.ty=r}set(t,e,s,i,o,r){return this.a=t,this.b=e,this.c=s,this.d=i,this.tx=o,this.ty=r,this}getArray(){return[this.a,this.b,this.c,this.d,this.tx,this.ty]}apply(t){const e=t.x,s=t.y;return{x:this.a*e+this.c*s+this.tx,y:this.b*e+this.d*s+this.ty}}applyInverse(t){const e=this.a,s=this.b,i=this.c,o=this.d,r=this.tx,h=this.ty,c=1/(e*o+i*-s),d=t.x,a=t.y;return{x:o*c*d+-i*c*a+(h*i-r*o)*c,y:e*c*a+-s*c*d+(-h*e+r*s)*c}}translate(t,e){return this.tx+=t,this.ty+=e,this}scale(t,e){return this.a*=t,this.d*=e,this.c*=t,this.b*=e,this.tx*=t,this.ty*=e,this}rotate(t){const e=Math.cos(t),s=Math.sin(t),i=this.a,o=this.c,r=this.tx;return this.a=i*e-this.b*s,this.b=i*s+this.b*e,this.c=o*e-this.d*s,this.d=o*s+this.d*e,this.tx=r*e-this.ty*s,this.ty=r*s+this.ty*e,this}append(t){const e=this.a,s=this.b,i=this.c,o=this.d;return this.a=t.a*e+t.b*i,this.b=t.a*s+t.b*o,this.c=t.c*e+t.d*i,this.d=t.c*s+t.d*o,this.tx=t.tx*e+t.ty*i+this.tx,this.ty=t.tx*s+t.ty*o+this.ty,this}appendFrom(t,e){const s=t.a,i=t.b,o=t.c,r=t.d,h=t.tx,c=t.ty,d=e.a,a=e.b,p=e.c,M=e.d;return this.a=s*d+i*p,this.b=s*a+i*M,this.c=o*d+r*p,this.d=o*a+r*M,this.tx=h*d+c*p+e.tx,this.ty=h*a+c*M+e.ty,this}prepend(t){const e=this.tx;if(t.a!==1||t.b!==0||t.c!==0||t.d!==1){const s=this.a,i=this.c;this.a=s*t.a+this.b*t.c,this.b=s*t.b+this.b*t.d,this.c=i*t.a+this.d*t.c,this.d=i*t.b+this.d*t.d}return this.tx=e*t.a+this.ty*t.c+t.tx,this.ty=e*t.b+this.ty*t.d+t.ty,this}invert(){const t=this.a,e=this.b,s=this.c,i=this.d,o=this.tx,r=t*i-e*s;return this.a=i/r,this.b=-e/r,this.c=-s/r,this.d=t/r,this.tx=(s*this.ty-i*o)/r,this.ty=-(t*this.ty-e*o)/r,this}isIdentity(){return this.a===1&&this.b===0&&this.c===0&&this.d===1&&this.tx===0&&this.ty===0}identity(){return this.a=1,this.b=0,this.c=0,this.d=1,this.tx=0,this.ty=0,this}clone(){const t=new z;return t.a=this.a,t.b=this.b,t.c=this.c,t.d=this.d,t.tx=this.tx,t.ty=this.ty,t}copyTo(t){return t.a=this.a,t.b=this.b,t.c=this.c,t.d=this.d,t.tx=this.tx,t.ty=this.ty,t}copyFrom(t){return this.a=t.a,this.b=t.b,this.c=t.c,this.d=t.d,this.tx=t.tx,this.ty=t.ty,this}equals(t){return t.a===this.a&&t.b===this.b&&t.c===this.c&&t.d===this.d&&t.tx===this.tx&&t.ty===this.ty}toString(){return`[Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`}}const N=Math.PI*2;function Bt(n){return n*180/Math.PI}function Tt(n){return n*Math.PI/180}const ht=n=>(n=n%N,n<0&&(n+=N),n),At=n=>(n=n%360,n<0&&(n+=360),n),at=(n,t)=>{const e=n.x*t.x+n.y*t.y,s=Math.sqrt(n.x*n.x+n.y*n.y)*Math.sqrt(t.x*t.x+t.y*t.y);let i=e/s;return i>1?i=1:i<-1&&(i=-1),Math.acos(i)},H=(n,t,e)=>{const s=n.x*t.x+n.y*t.y,i=Math.sqrt(n.x*n.x+n.y*n.y)*Math.sqrt(t.x*t.x+t.y*t.y);let o=s/i;o>1?o=1:o<-1&&(o=-1);let r=Math.acos(o);const h=n.x*t.y-n.y*t.x;return(e?h>0:h<0)&&(r=N-r),r},Lt=(n,t={x:0,y:-1})=>{const s=new z(n[0],n[1],n[2],n[3],0,0).apply(t);return H(t,s)},Rt=n=>n[0]*n[3]-n[1]*n[2]<0,st=(n,t)=>({x:(n.x+t.x)/2,y:(n.y+t.y)/2}),W=(n,t)=>({x:n.x+t.x,y:n.y+t.y}),_=(n,t)=>({x:n.x-t.x,y:n.y-t.y}),Z=n=>n.x===0&&n.y===0,Xt=1e-10,yt=(n,t,e=Xt)=>Math.abs(n.x-t.x)<e&&Math.abs(n.y-t.y)<e,A=(n,t)=>Math.sqrt(Math.pow(n.x-t.x,2)+Math.pow(n.y-t.y,2)),U=(n,t,e)=>n*(1-e)+t*e,q=(n,t,e)=>({x:U(n.x,t.x,e),y:U(n.y,t.y,e)}),G=n=>{const t=Math.sqrt(n.x*n.x+n.y*n.y);return{x:n.x/t,y:n.y/t}},Yt=(n,t,e)=>{const s=_(n[1],n[0]),i={x:-s.y,y:s.x},o=G(i),r={x:t.x+o.x*e,y:t.y+o.y*e},h={x:t.x-o.x*e,y:t.y-o.y*e};return[r,h]},J=(n,t)=>{if(n.length===4){const[e,s,i,o]=n,r=t*t,h=1-t,c=h*h,d=c*h,a=3*t*c,p=3*r*h,M=r*t;return{x:d*e.x+a*s.x+p*i.x+M*o.x,y:d*e.y+a*s.y+p*i.y+M*o.y}}for(;n.length>1;){const e=[];for(let s=0,i=n.length-1;s<i;s++)e.push(q(n[s],n[s+1],t));n=e}return n[0]},ut=(n,t,e)=>{const s=n.point,i=t.point,o=W(n.point,n.out),r=W(t.point,t.in),h=q(s,o,e),c=q(o,r,e),d=q(r,i,e),a=q(h,c,e),p=q(c,d,e),M=q(a,p,e);return[{point:n.point,in:n.in,out:_(h,n.point)},{point:M,in:_(a,M),out:_(p,M)},{point:t.point,in:_(d,t.point),out:t.out}]},Nt=()=>[1,0,0,1,0,0],lt=(n,t)=>{const e=n[0],s=n[1],i=n[2],o=n[3];return[t[0]*e+t[1]*i,t[0]*s+t[1]*o,t[2]*e+t[3]*i,t[2]*s+t[3]*o,t[4]*e+t[5]*i+n[4],t[4]*s+t[5]*o+n[5]]},it=(n,t)=>({x:t.x*n[0]+t.y*n[2]+n[4],y:t.x*n[1]+t.y*n[3]+n[5]}),Wt=(n,t)=>it(xt(n),t),xt=n=>{const t=n[0],e=n[1],s=n[2],i=n[3],o=n[4],r=t*i-e*s;return[i/r,-e/r,-s/r,t/r,(s*n[5]-i*o)/r,-(t*n[5]-e*o)/r]},ft=(n,t)=>[n,0,0,t,0,0],qt=n=>lt(n.transform,ft(n.width,n.height)),dt=(n,t,e,s,i)=>{if(!e)return{x:n,y:t};const o=Math.cos(e),r=Math.sin(e);return{x:(n-s)*o-(t-i)*r+s,y:(n-s)*r+(t-i)*o+i}},mt=.5522847498307936,gt=(n,t)=>({x:Math.min(n.x,t.x),y:Math.min(n.y,t.y),width:Math.abs(n.x-t.x),height:Math.abs(n.y-t.y)}),Ft=(n,t,e=0)=>(t.transform&&(n=new z(...t.transform).applyInverse(n)),n.x>=-e&&n.y>=-e&&n.x<=t.width+e&&n.y<=t.height+e),Et=(n,t,e,s=0)=>{const i=t.x-s,o=t.y-s,r=t.width+s*2,h=t.height+s*2;return n.x>=i&&n.y>=o&&n.x<=i+r&&n.y<=o+h?n.x<=i+e[0]&&n.y<=o+e[0]?(n.x-i-e[0])**2+(n.y-o-e[0])**2<=e[0]**2:n.x>=i+r-e[1]&&n.y<=o+e[1]?(n.x-i-r+e[1])**2+(n.y-o-e[1])**2<=e[1]**2:n.x>=i+r-e[2]&&n.y>=o+h-e[2]?(n.x-i-r+e[2])**2+(n.y-o-h+e[2])**2<=e[2]**2:n.x<=i+e[3]&&n.y>=o+h-e[3]?(n.x-i-e[3])**2+(n.y-o-h+e[3])**2<=e[3]**2:!0:!1},Ot=({x:n,y:t,width:e,height:s})=>{const i=n+e,o=t+s;return gt({x:n,y:t},{x:i,y:o})},_t=(...n)=>{if(n.length===0)throw new Error("the count of rect can not be 0");let t=1/0,e=1/0,s=-1/0,i=-1/0;for(const o of n)t=Math.min(t,o.x),e=Math.min(e,o.y),s=Math.max(s,o.x+o.width),i=Math.max(i,o.y+o.height);return{x:t,y:e,width:s-t,height:i-e}},Dt=(n,t)=>n.x<=t.x+t.width&&n.x+n.width>=t.x&&n.y<=t.y+t.height&&n.y+n.height>=t.y,kt=(n,t)=>n.x<=t.x&&n.y<=t.y&&n.x+n.width>=t.x+t.width&&n.y+n.height>=t.y+t.height,jt=(n,t)=>{typeof t=="number"&&(t=[t,t,t,t]);const{x:e,y:s,width:i,height:o}=n;return{x:e-t[3],y:s-t[0],width:i+t[1]+t[3],height:o+t[0]+t[2]}},$t=n=>{const{x:t,y:e,width:s,height:i}=n,o=s/2,r=i/2;return[{x:t+o,y:e},{x:t+s,y:e+r},{x:t+o,y:e+i},{x:t,y:e+r}]},Vt=(n,t)=>{const{x:e,y:s}=n,i=t.x-n.x,o=t.y-n.y,r=ht(Math.atan2(o,i)),h=e+i/2,c=s+o/2,d=dt(e,s,-r,h,c);return{x:d.x,y:d.y,width:Math.sqrt(i*i+o*o),height:0,rotation:r}},ot=(n,t)=>{const{x:e,y:s,width:i,height:o}=n;let r=[{x:e,y:s},{x:e+i,y:s},{x:e+i,y:s+o},{x:e,y:s+o}];if(t){const h=new z(...t);r=r.map(c=>{const d=h.apply(c);return{x:d.x,y:d.y}})}return r},Kt=n=>{const t=ot({x:0,y:0,width:n.width,height:n.height},n.transform);let e=1/0,s=1/0,i=-1/0,o=-1/0;for(const r of t)e=Math.min(e,r.x),s=Math.min(s,r.y),i=Math.max(i,r.x),o=Math.max(o,r.y);return{x:e,y:s,width:i-e,height:o-s}},pt=n=>{const t=new z(n.transform[0],n.transform[1],n.transform[2],n.transform[3],0,0),e=t.apply({x:n.width,y:0}),s=t.apply({x:0,y:n.height}),i={x:0,y:0};return{width:A(e,i),height:A(s,i)}},Ht=n=>{const t=pt(n),e=t.width?n.width/t.width:1,s=t.height?n.height/t.height:1,i=new z().scale(e,s),o=new z(...n.transform).append(i);return{width:t.width,height:t.height,transform:o.getArray()}},rt=n=>({minX:n.x,minY:n.y,maxX:n.x+n.width,maxY:n.y+n.height}),Gt=n=>({x:n.minX,y:n.minY,width:n.maxX-n.minX,height:n.maxY-n.minY}),Zt=(n,t=0)=>{const{minX:e,minY:s,maxX:i,maxY:o}=rt(n);if(t<=0)return[{type:"M",points:[{x:e,y:s}]},{type:"L",points:[{x:i,y:s}]},{type:"L",points:[{x:i,y:o}]},{type:"L",points:[{x:e,y:o}]},{type:"Z",points:[]}];const r=n.width/2,h=n.height/2,c=Math.min(t,r,h),d=c===r,a=c===h,p=c*mt,M=c*mt,I=[{type:"M",points:[{x:e,y:s+c}]},{type:"C",points:[{x:e,y:s+c-M},{x:e+c-p,y:s},{x:e+c,y:s}]}];return d||I.push({type:"L",points:[{x:i-c,y:s}]}),I.push({type:"C",points:[{x:i-c+p,y:s},{x:i,y:s+c-M},{x:i,y:s+c}]}),a||I.push({type:"L",points:[{x:i,y:o-c}]}),I.push({type:"C",points:[{x:i,y:o-c+M},{x:i-c+p,y:o},{x:i-c,y:o}]}),d||I.push({type:"L",points:[{x:e+c,y:o}]}),I.push({type:"C",points:[{x:e+c-p,y:o},{x:e,y:o-c+M},{x:e,y:o-c}]}),a||I.push({type:"L",points:[{x:e,y:s+c}]}),I.push({type:"Z",points:[]}),I},wt=(n,t,e=0)=>t.x>=n.minX-e&&t.y>=n.minY-e&&t.x<=n.maxX+e&&t.y<=n.maxY+e,Ut=n=>{if(n.length===0)throw new Error("the count of boxes can not be 0");let t=1/0,e=1/0,s=-1/0,i=-1/0;for(const o of n)t=Math.min(t,o.minX),e=Math.min(e,o.minY),s=Math.max(s,o.maxX),i=Math.max(i,o.maxY);return{minX:t,minY:e,maxX:s,maxY:i}},Jt=(n,t)=>n.minX<=t.maxX&&n.maxX>=t.minX&&n.minY<=t.maxY&&n.maxY>=t.minY,Qt=(n,t)=>n.minX<=t.minX&&n.minY<=t.minY&&n.maxX>=t.maxX&&n.maxY>=t.maxY,ct=n=>{let t=1/0,e=1/0,s=-1/0,i=-1/0;for(const o of n)t=Math.min(t,o.x),e=Math.min(e,o.y),s=Math.max(s,o.x),i=Math.max(i,o.y);return{minX:t,minY:e,maxX:s,maxY:i}},tn=(n,t)=>{let e=0,s=0,i=n.width,o=n.height;t&&(e-=t,s-=t,i+=t*2,o+=t*2);const r=n.transform,h=ot({x:e,y:s,width:i,height:o}).map(c=>it(r,c));return ct(h)},nn=(n,t)=>{const e=n.x-t.x,s=n.y-t.y;return e*e+s*s<=t.radius*t.radius},en=n=>{const t=.5522847498307936,{minX:e,minY:s,maxX:i,maxY:o}=rt(n),r=(e+i)/2,h=(s+o)/2,c=n.width/2,d=n.height/2,a=c*t,p=d*t;return[{type:"M",points:[{x:i,y:h}]},{type:"C",points:[{x:i,y:h+p},{x:r+a,y:o},{x:r,y:o}]},{type:"C",points:[{x:r-a,y:o},{x:e,y:h+p},{x:e,y:h}]},{type:"C",points:[{x:e,y:h-p},{x:r-a,y:s},{x:r,y:s}]},{type:"C",points:[{x:i,y:h-p},{x:r+a,y:s},{x:i,y:h}]},{type:"Z",points:[]}]},tt=(n,t,e,s=!0)=>{if(n.x===t.x&&n.y===t.y)return{t:0,point:{x:n.x,y:n.y}};const i=t.x-n.x,o=t.y-n.y;let r=((e.x-n.x)*i+(e.y-n.y)*o)/(i*i+o*o);s||(r=Math.max(0,Math.min(1,r)));const h={x:n.x+r*i,y:n.y+r*o};return{t:r,point:h}},Mt=(n,t,e=4)=>{let s={x:0,y:0},i=1/0;for(let o=1;o<=e;o++){const r=Math.PI/e*o,h={x:n.x+Math.cos(r),y:n.y+Math.sin(r)},{point:c}=tt(n,h,t),d=A(c,t);if(d===0)return c;d<i&&(i=d,s=c)}return s},bt=(n,t,e,s)=>{const{x:i,y:o}=n,{x:r,y:h}=t,{x:c,y:d}=e,{x:a,y:p}=s,M=h-o,I=i-r,P=i*h-r*o,f=p-d,B=c-a,y=c*p-a*d,m=M*B-I*f;if(Math.abs(m)<1e-9)return null;const u=(P*B-y*I)/m,l=(M*y-P*f)/m;return{x:u,y:l}};var sn=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function on(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}var vt={exports:{}};(function(n,t){(function(e,s){s(n)})(sn,function(e){function s(y,m){if(!(y instanceof m))throw new TypeError("Cannot call a class as a function")}/**
 *  @preserve  JavaScript implementation of
 *  Algorithm for Automatically Fitting Digitized Curves
 *  by Philip J. Schneider
 *  "Graphics Gems", Academic Press, 1990
 *
 *  The MIT License (MIT)
 *
 *  https://github.com/soswow/fit-curves
 */function i(y,m,u){if(!Array.isArray(y))throw new TypeError("First argument should be an array");if(y.forEach(function(w){if(!Array.isArray(w)||w.some(function(b){return typeof b!="number"})||w.length!==y[0].length)throw Error("Each point should be an array of numbers. Each point should have the same amount of numbers.")}),y=y.filter(function(w,b){return b===0||!w.every(function(C,S){return C===y[b-1][S]})}),y.length<2)return[];var l=y.length,g=P(y[1],y[0]),v=P(y[l-2],y[l-1]);return o(y,g,v,m,u)}function o(y,m,u,l,g){var v=20,w,b,C,S,F,L,j,R,$,V,T,D,K;if(y.length===2)return D=f.vectorLen(f.subtract(y[0],y[1]))/3,w=[y[0],f.addArrays(y[0],f.mulItems(m,D)),f.addArrays(y[1],f.mulItems(u,D)),y[1]],[w];b=a(y);var Y=r(y,b,b,m,u,g);if(w=Y[0],S=Y[1],L=Y[2],S===0||S<l)return[w];if(S<l*l)for(C=b,F=S,j=L,K=0;K<v;K++){C=c(w,y,C);var k=r(y,b,C,m,u,g);if(w=k[0],S=k[1],L=k[2],S<l)return[w];if(L===j){var E=S/F;if(E>.9999&&E<1.0001)break}F=S,j=L}if(T=[],R=f.subtract(y[L-1],y[L+1]),R.every(function(zn){return zn===0})){R=f.subtract(y[L-1],y[L]);var O=[-R[1],R[0]];R[0]=O[0],R[1]=O[1]}return $=f.normalize(R),V=f.mulItems($,-1),T=T.concat(o(y.slice(0,L+1),m,$,l,g)),T=T.concat(o(y.slice(L),V,u,l,g)),T}function r(y,m,u,l,g,v){var w,b,C;w=h(y,u,l,g);var S=p(y,w,m);return b=S[0],C=S[1],v&&v({bez:w,points:y,params:m,maxErr:b,maxPoint:C}),[w,b,C]}function h(y,m,u,l){var g,v,w,b,C,S,F,L,j,R,$,V,T,D,K,Y,k,E=y[0],O=y[y.length-1];for(g=[E,null,null,O],v=f.zeros_Xx2x2(m.length),T=0,D=m.length;T<D;T++)Y=m[T],k=1-Y,w=v[T],w[0]=f.mulItems(u,3*Y*(k*k)),w[1]=f.mulItems(l,3*k*(Y*Y));for(b=[[0,0],[0,0]],C=[0,0],T=0,D=y.length;T<D;T++)Y=m[T],w=v[T],b[0][0]+=f.dot(w[0],w[0]),b[0][1]+=f.dot(w[0],w[1]),b[1][0]+=f.dot(w[0],w[1]),b[1][1]+=f.dot(w[1],w[1]),K=f.subtract(y[T],B.q([E,E,O,O],Y)),C[0]+=f.dot(w[0],K),C[1]+=f.dot(w[1],K);return S=b[0][0]*b[1][1]-b[1][0]*b[0][1],F=b[0][0]*C[1]-b[1][0]*C[0],L=C[0]*b[1][1]-C[1]*b[0][1],j=S===0?0:L/S,R=S===0?0:F/S,V=f.vectorLen(f.subtract(E,O)),$=1e-6*V,j<$||R<$?(g[1]=f.addArrays(E,f.mulItems(u,V/3)),g[2]=f.addArrays(O,f.mulItems(l,V/3))):(g[1]=f.addArrays(E,f.mulItems(u,j)),g[2]=f.addArrays(O,f.mulItems(l,R))),g}function c(y,m,u){return u.map(function(l,g){return d(y,m[g],l)})}function d(y,m,u){var l=f.subtract(B.q(y,u),m),g=B.qprime(y,u),v=f.mulMatrix(l,g),w=f.sum(f.squareItems(g))+2*f.mulMatrix(l,B.qprimeprime(y,u));return w===0?u:u-v/w}function a(y){var m=[],u,l,g;return y.forEach(function(v,w){u=w?l+f.vectorLen(f.subtract(v,g)):0,m.push(u),l=u,g=v}),m=m.map(function(v){return v/l}),m}function p(y,m,u){var l,g,v,w,b,C,S,F;g=0,v=Math.floor(y.length/2);var L=M(m,10);for(b=0,C=y.length;b<C;b++)S=y[b],F=I(m,u[b],L,10),w=f.subtract(B.q(m,F),S),l=w[0]*w[0]+w[1]*w[1],l>g&&(g=l,v=b);return[g,v]}var M=function(m,u){for(var l,g=[0],v=m[0],w=0,b=1;b<=u;b++)l=B.q(m,b/u),w+=f.vectorLen(f.subtract(l,v)),g.push(w),v=l;return g=g.map(function(C){return C/w}),g};function I(y,m,u,l){if(m<0)return 0;if(m>1)return 1;for(var g,v,w,b,C,S=1;S<=l;S++)if(m<=u[S]){b=(S-1)/l,w=S/l,v=u[S-1],g=u[S],C=(m-v)/(g-v)*(w-b)+b;break}return C}function P(y,m){return f.normalize(f.subtract(y,m))}var f=function(){function y(){s(this,y)}return y.zeros_Xx2x2=function(u){for(var l=[];u--;)l.push([0,0]);return l},y.mulItems=function(u,l){return u.map(function(g){return g*l})},y.mulMatrix=function(u,l){return u.reduce(function(g,v,w){return g+v*l[w]},0)},y.subtract=function(u,l){return u.map(function(g,v){return g-l[v]})},y.addArrays=function(u,l){return u.map(function(g,v){return g+l[v]})},y.addItems=function(u,l){return u.map(function(g){return g+l})},y.sum=function(u){return u.reduce(function(l,g){return l+g})},y.dot=function(u,l){return y.mulMatrix(u,l)},y.vectorLen=function(u){return Math.hypot.apply(Math,u)},y.divItems=function(u,l){return u.map(function(g){return g/l})},y.squareItems=function(u){return u.map(function(l){return l*l})},y.normalize=function(u){return this.divItems(u,this.vectorLen(u))},y}(),B=function(){function y(){s(this,y)}return y.q=function(u,l){var g=1-l,v=f.mulItems(u[0],g*g*g),w=f.mulItems(u[1],3*g*g*l),b=f.mulItems(u[2],3*g*l*l),C=f.mulItems(u[3],l*l*l);return f.addArrays(f.addArrays(v,w),f.addArrays(b,C))},y.qprime=function(u,l){var g=1-l,v=f.mulItems(f.subtract(u[1],u[0]),3*g*g),w=f.mulItems(f.subtract(u[2],u[1]),6*g*l),b=f.mulItems(f.subtract(u[3],u[2]),3*l*l);return f.addArrays(f.addArrays(v,w),b)},y.qprimeprime=function(u,l){return f.addArrays(f.mulItems(f.addArrays(f.subtract(u[2],f.mulItems(u[1],2)),u[0]),6*(1-l)),f.mulItems(f.addArrays(f.subtract(u[3],f.mulItems(u[2],2)),u[1]),6*l))},y}();e.exports=i,e.exports.fitCubic=o,e.exports.createTangent=P})})(vt);var rn=vt.exports;const It=on(rn),cn=(n,t)=>{const e=It(n.map(({point:i})=>[i.x,i.y]),t),s=[];for(let i=0,o=e.length;i<=o;i++){const r=e[i],h=e[i-1],c=r?{x:r[0][0],y:r[0][1]}:{x:h[3][0],y:h[3][1]},d=r?{x:r[1][0]-c.x,y:r[1][1]-c.y}:{x:0,y:0},a=h?{x:h[2][0]-c.x,y:h[2][1]-c.y}:{x:0,y:0};s.push({point:c,in:a,out:d})}return s},hn=(n,t,e)=>{const s=n.segs;if(!n.closed&&(t<0||t>=s.length-1))return s.splice(t,1),n;let o=t+1;n.closed&&(o%=s.length);const r=s[t],h=s[o],c=ut(r,h,e);return o===0?(n.segs.splice(t,1,c[0],c[1]),n.segs.splice(0,1,c[2])):n.segs.splice(t,2,...c),n},an=(n,t)=>{const e=n.segs;if(e.length<=1)return n.segs=[],n;if(!n.closed&&(t<=0||t>=e.length-1))return e.splice(t,1),n;let i=t-1,o=t+1;n.closed&&(i%=e.length,o%=e.length);const r=e[t],h=e[i],c=e[o];if(Z(h.out)&&Z(c.in)&&Z(r.in)&&Z(r.out))return e.splice(t,1),n;const a=[h.point,W(h.out,h.point),W(r.in,r.point),r.point],p=[r.point,W(r.out,r.point),W(c.in,c.point),c.point],M=[J(a,.3),J(a,.6)],I=[J(p,.3),J(p,.6)],P=It([h.point,...M,r.point,...I,c.point].map(({x:g,y:v})=>[g,v]),9999)[0],f=_({x:P[1][0],y:P[1][1]},h.point),B=_({x:P[2][0],y:P[2][1]},c.point);let y=G(h.out);(Number.isNaN(y.x)||Number.isNaN(y.y))&&(y=G(f));let m=G(c.in);(Number.isNaN(m.x)||Number.isNaN(m.y))&&(m=G(B));const u=A({x:0,y:0},f),l=A({x:0,y:0},B);return h.out={x:y.x*u,y:y.y*u},c.in={x:m.x*l,y:m.y*l},e.splice(t,1),n};class yn{constructor(t){X(this,"points");X(this,"dpoints",[]);X(this,"_bbox",null);X(this,"lut",[]);this.points=t,this.dpoints[0]={x:3*(t[1].x-t[0].x),y:3*(t[1].y-t[0].y)},this.dpoints[1]={x:3*(t[2].x-t[1].x),y:3*(t[2].y-t[1].y)},this.dpoints[2]={x:3*(t[3].x-t[2].x),y:3*(t[3].y-t[2].y)}}compute(t){const e=t*t,s=1-t,i=s*s,o=i*s,r=3*t*i,h=3*e*s,c=e*t,[d,a,p,M]=this.points;return{x:o*d.x+r*a.x+h*p.x+c*M.x,y:o*d.y+r*a.y+h*p.y+c*M.y}}extrema(){const t=this.dpoints,e=[...zt(t[0].x,t[1].x,t[2].x),...zt(t[0].y,t[1].y,t[2].y)].filter(s=>s>=0&&s<=1);return Array.from(new Set(e))}getBbox(){if(!this._bbox){const t=this.extrema().map(e=>this.compute(e));this._bbox=ct([...t,this.points[0],this.points[3]])}return this._bbox}hitTest(t,e){if(!wt(this.getBbox(),t,e))return!1;const s=this.getLookupTable();let i=Number.MAX_SAFE_INTEGER,o=-1;for(let a=0;a<s.length;a++){const p=s[a],M=A(t,p.pt);if(M<=e)return!0;M<i&&(i=M,o=a)}const r=s[o].t,h=o>0?s[o-1].t:r,c=o<s.length-1?s[o+1].t:r,d=.001;for(let a=h;a<=c;a+=d){const p=this.compute(a);if(A(t,p)<=e)return!0}return!1}getLookupTable(){if(this.lut.length===0)for(let e=0;e<=100;e++){const s=e/100,i=this.compute(s);this.lut[e]={t:s,pt:i}}return this.lut}project(t){const e=this.getLookupTable();let s=Number.MAX_SAFE_INTEGER,i=-1;for(let a=0;a<e.length;a++){const p=e[a],M=A(t,p.pt);if(M<s&&(s=M,i=a,M===0))break}if(s===0){const a=this.compute(e[i].t);return{point:a,t:e[i].t,dist:A(t,a)}}let o=e[i].t;const r=i>0?e[i-1].t:o,h=i<e.length-1?e[i+1].t:o,c=.001;for(let a=r;a<=h;a+=c){const p=this.compute(a),M=A(t,p);if(M<s&&(s=M,o=a,M===0))break}o<0&&(o=0),o>1&&(o=1);const d=this.compute(o);return{point:d,t:o,dist:A(t,d)}}toCommand(){const[t,e,s,i]=this.points;return t.x===e.x&&e.x===s.x&&s.x===i.x?[{type:"M",points:[t]},{type:"C",points:[e,s,i]}]:[{type:"M",points:[t]},{type:"C",points:[e,s,i]}]}}const zt=(n,t,e)=>{const s=n-2*t+e;if(s!==0){const i=t*t-n*e;if(i<0)return[];const o=Math.sqrt(i),r=n-t;return o===0?[(r-o)/s]:[(r-o)/s,(r+o)/s]}else return n!==t?[n/(n-t)/2]:[]};class nt{constructor(t){X(this,"bezierLists");const e=[];for(let s=0;s<t.length;s++){const i=t[s],o=i.segs;e[s]={isClosed:i.closed,curves:[]};for(let r=1;r<=o.length;r++){if(r===o.length&&!i.closed)continue;const h=o[r%o.length],c=o[r-1];e[s].curves.push(new yn([c.point,nt.getHandleOut(c),nt.getHandleIn(h),h.point]))}}this.bezierLists=e}static getHandleIn(t){return W(t.point,t.in)}static getHandleOut(t){return W(t.point,t.out)}getBbox(){let t=1/0,e=1/0,s=-1/0,i=-1/0;for(const{curves:o}of this.bezierLists)for(const r of o){const h=r.getBbox();t=Math.min(t,h.minX),e=Math.min(e,h.minY),s=Math.max(s,h.maxX),i=Math.max(i,h.maxY)}return{minX:t,minY:e,maxX:s,maxY:i}}getBRect(){const t=this.getBbox();return t.minX===1/0?{x:0,y:0,width:100,height:100}:{x:t.minX,y:t.minY,width:t.maxX-t.minX,height:t.maxY-t.minY}}hitTest(t,e){for(const{curves:s}of this.bezierLists)for(const i of s)if(i.hitTest(t,e))return!0;return!1}project(t,e=1/0){const s={dist:e,point:{x:0,y:0},index:[-1,-1],t:-1};for(let i=0;i<this.bezierLists.length;i++){const{curves:o}=this.bezierLists[i];for(let r=0;r<o.length;r++){const c=o[r].project(t);if(c.dist<s.dist&&(s.dist=c.dist,s.point=c.point,s.index=[i,r],s.t=c.t),c.dist===0)break}}return s.index[0]===-1?null:s}toCommands(){const t=[];for(const{isClosed:e,curves:s}of this.bezierLists){for(let i=0;i<s.length;i++){const r=s[i].toCommand();i===0?t.push(...r):t.push(...r.slice(1))}e&&t.push({type:"Z",points:[]})}return t}}const un=(n,t)=>n.map(e=>e.type+e.points.map(s=>St(s.x,t)+" "+St(s.y,t)).join(" ")).join(" "),St=(n,t=2)=>Number(n.toFixed(t)),ln=({center:n,r:t,startAngle:e,endAngle:s,angleDir:i=!0})=>{i===!1&&([e,s]=[s,e]);const o=(s-e+Math.PI*2)%(Math.PI*2),r=o/2,h=4*(1-Math.cos(r))/(3*Math.sin(r)),c=new z().rotate(e).scale(t,t).translate(n.x,n.y);s-=e,e=0;const d=c.apply({x:1,y:0}),a=c.apply({x:1,y:h}),p=c.apply({x:Math.cos(o)+h*Math.sin(o),y:Math.sin(o)-h*Math.cos(o)}),M=c.apply({x:Math.cos(o),y:Math.sin(o)});return i?[d,a,p,M]:[M,p,a,d]},xn=(n,t)=>{const e=n.width/2,s=n.height/2,i=[{x:e,y:0}],o=Math.PI*2/t,r=new z().translate(-e,-s).rotate(o).translate(e,s);let h=i[0];for(let d=1;d<t;d++){const{x:a,y:p}=r.apply(h),M={x:a,y:p};i.push(M),h=M}const c=n.width/n.height;for(let d=1;d<t;d++){const a=i[d];a.x=U(e,a.x,c)}return i},fn=(n,t)=>{let e;for(let s=0;s<n.length;s++){const i=n[s],o=n[(s+1)%n.length],r={x:o.x-i.x,y:o.y-i.y},h={x:t.x-i.x,y:t.y-i.y},c=Math.sign(r.x*h.y-r.y*h.x);if(c!==0){if(e===void 0)e=c;else if(e!==c)return!1}}return!0},dn=(n,t)=>{let e=!1;for(let s=0;s<n.length;s++){let i=n[s],o=n[(s+1)%n.length];if(i.y>o.y&&([i,o]=[o,i]),i.y<=t.y&&o.y>t.y){const r=(t.x-i.x)*(o.y-i.y)-(o.x-i.x)*(t.y-i.y);if(r===0)return!0;r>0&&(e=!e)}}return e},mn=(n,t)=>{const e=[];for(let s=0;s<n.length;s++){const i=n[(s-1+n.length)%n.length],o=n[s],r=n[(s+1)%n.length],h=gn(st(i,o),o,st(o,r),t),c=Ct([i,o],[o,r],h);if(s===0)e.push({type:"M",points:[c.start]});else{const a=e[e.length-1].points,p=a[a.length-1];yt(c.start,p)||e.push({type:"L",points:[c.start]})}const d=ln({center:c.center,r:h,startAngle:c.startAngle,endAngle:c.endAngle,angleDir:c.angleDir});e.push({type:"C",points:[d[1],d[2],d[3]]})}return e.push({type:"Z",points:[]}),e},gn=(n,t,e,s)=>{const i={x:t.x-n.x,y:t.y-n.y},o={x:t.x-e.x,y:t.y-e.y},r=at(i,o)/2,h=Math.tan(r)*A(n,t),c=Math.tan(r)*A(t,e);return Math.min(s,h,c)},Ct=(n,t,e)=>{const s=n[0],i=n[1],o=t[0],r=t[1],h={x:s.x-i.x,y:s.y-i.y},c={x:r.x-o.x,y:r.y-o.y},d=h.x*c.y-c.x*h.y;if(d===0)return null;let a,p;d<0?(a={x:h.y,y:-h.x},p={x:-c.y,y:c.x}):(a={x:-h.y,y:h.x},p={x:c.y,y:-c.x});const M=e/A(s,i),I={x:a.x*M,y:a.y*M},P=[{x:s.x+I.x,y:s.y+I.y},{x:i.x+I.x,y:i.y+I.y}],f=e/A(o,r),B={x:p.x*f,y:p.y*f},y=[{x:o.x+B.x,y:o.y+B.y},{x:r.x+B.x,y:r.y+B.y}],m=bt(P[0],P[1],y[0],y[1]),{point:u}=tt(s,i,m,!0),{point:l}=tt(o,r,m,!0),g={x:1,y:0},v=H(g,{x:u.x-m.x,y:u.y-m.y}),w=H(g,{x:l.x-m.x,y:l.y-m.y});return{center:m,start:u,end:l,startAngle:v,endAngle:w,angleDir:d<0}},pn=(n,t,e,s={keepPolarSnap:!1,scaleFromCenter:!1})=>{if(!["se","ne","nw","sw"].includes(n))throw new Error(`invalid type "${n}"`);const i=n==="se"||n==="ne";let o={x:0,y:0};s.scaleFromCenter?o=new z(...e.transform).apply({x:e.width/2,y:e.height/2}):i?o={x:e.transform[4],y:e.transform[5]}:o=new z(...e.transform).apply({x:e.width,y:e.height}),s.keepPolarSnap&&(t=Mt(o,t));let r=A(t,o);if(s.scaleFromCenter&&(r*=2),i){const h={x:t.x-o.x,y:t.y-o.y},c=H({x:1,y:0},{x:t.x-o.x,y:t.y-o.y}),d=new z().rotate(c).translate(o.x,o.y);return s.scaleFromCenter&&d.translate(-h.x,-h.y),{width:r,height:0,transform:d.getArray()}}else{const h={x:o.x-t.x,y:o.y-t.y},c=H({x:1,y:0},h),d=new z().rotate(c),a=d.apply({x:r,y:e.height});return d.translate(o.x-a.x,o.y-a.y),s.scaleFromCenter&&d.translate(h.x,h.y),{width:r,height:0,transform:d.getArray()}}},et=(n,t)=>({width:n*2,height:t*2}),wn={sw:{getLocalOrigin:n=>({x:n,y:0}),getNewSize:(n,t)=>({width:t.x-n.x,height:n.y-t.y}),isBaseWidthWhenKeepRatio:n=>n,getSizeWhenScaleFromCenter:et},se:{getLocalOrigin:()=>({x:0,y:0}),getNewSize:(n,t)=>({width:n.x-t.x,height:n.y-t.y}),isBaseWidthWhenKeepRatio:n=>n,getSizeWhenScaleFromCenter:et},nw:{getLocalOrigin:(n,t)=>({x:n,y:t}),getNewSize:(n,t)=>({width:t.x-n.x,height:t.y-n.y}),isBaseWidthWhenKeepRatio:n=>n,getSizeWhenScaleFromCenter:et},ne:{getLocalOrigin:(n,t)=>({x:0,y:t}),getNewSize:(n,t)=>({width:n.x-t.x,height:t.y-n.y}),isBaseWidthWhenKeepRatio:n=>n,getSizeWhenScaleFromCenter:et},n:{getLocalOrigin:(n,t)=>({x:n/2,y:t}),getNewSize:(n,t,e)=>({width:e.width,height:t.y-n.y}),isBaseWidthWhenKeepRatio:()=>!1,getSizeWhenScaleFromCenter:(n,t)=>({width:n,height:t*2})},s:{getLocalOrigin:n=>({x:n/2,y:0}),getNewSize:(n,t,e)=>({width:e.width,height:n.y-t.y}),isBaseWidthWhenKeepRatio:()=>!1,getSizeWhenScaleFromCenter:(n,t)=>({width:n,height:t*2})},e:{getLocalOrigin:(n,t)=>({x:0,y:t/2}),getNewSize:(n,t,e)=>({width:n.x-t.x,height:e.height}),isBaseWidthWhenKeepRatio:()=>!0,getSizeWhenScaleFromCenter:(n,t)=>({width:n*2,height:t})},w:{getLocalOrigin:(n,t)=>({x:n,y:t/2}),getNewSize:(n,t,e)=>({width:t.x-n.x,height:e.height}),isBaseWidthWhenKeepRatio:()=>!0,getSizeWhenScaleFromCenter:(n,t)=>({width:n*2,height:t})}},Mn=(n,t,e,s)=>{const i=wn[n];if(!i)throw new Error(`resize type ${n} is invalid`);const{keepRatio:o,scaleFromCenter:r,noChangeWidthAndHeight:h,flip:c=!0}=s??{},d=new z(...e.transform),a={width:0,height:0,transform:d.clone()},p=r?{x:e.width/2,y:e.height/2}:i.getLocalOrigin(e.width,e.height),M=d.applyInverse(t);let I=i.getNewSize(M,p,e);if(r&&(I=i.getSizeWhenScaleFromCenter(I.width,I.height)),o){const l=e.width/e.height,v=Math.abs(I.width/I.height)>l;i.isBaseWidthWhenKeepRatio(v)?I.height=Math.sign(I.height)*Math.abs(I.width)/l:I.width=Math.sign(I.width)*Math.abs(I.height)*l}const P=new z,f=Math.sign(I.width)||1,B=Math.sign(I.height)||1;h?(P.scale(I.width/e.width,I.height/e.height),a.width=e.width,a.height=e.height):(a.width=Math.abs(I.width),a.height=Math.abs(I.height),P.scale(f,B)),a.transform=a.transform.append(P);const y=a.transform.apply(r?{x:a.width/2,y:a.height/2}:i.getLocalOrigin(a.width,a.height)),m=d.apply(p),u={x:m.x-y.x,y:m.y-y.y};if(a.transform.prepend(new z().translate(u.x,u.y)),!c){const l=new z().translate(-a.width/2,-a.height/2).scale(f,B).translate(a.width/2,a.height/2);a.transform.append(l)}return{width:a.width,height:a.height,transform:a.transform.getArray()}},bn=(n,t,e)=>{const s=n.width/2,i=n.height/2,o=new Array(t*2);o[0]={x:s,y:0};const r=Math.PI*2/t,h=new z().translate(-s,-i).rotate(r).translate(s,i);let c=o[0];for(let p=1;p<t;p++){const{x:M,y:I}=h.apply(c),P={x:M,y:I};o[p*2]=P,c=P}const d=new z().translate(-s,-i).rotate(r/2).translate(s,i);c=q({x:s,y:i},d.apply(o[0]),e),o[1]=c;for(let p=1;p<t;p++){const{x:M,y:I}=h.apply(c),P={x:M,y:I};o[p*2+1]=P,c=P}const a=n.width/n.height;for(let p=1;p<o.length;p++){const M=o[p];M.x=U(s,M.x,a)}return o};let Q=null;const Pt=()=>Q||(Q=document.createElement("canvas").getContext("2d"),Q.fontKerning="none",Q),vn=(n,t)=>{const e=[],s={x:0,y:0},i=Pt();i.font=`${t.fontSize}px ${t.fontFamily}`;for(const o of n){const r=i.measureText(o);e.push({position:{...s},width:r.width,height:r.fontBoundingBoxAscent+r.fontBoundingBoxDescent,fontBoundingBoxAscent:r.fontBoundingBoxAscent}),s.x+=r.width}return e.push({position:{...s},width:0,height:0,fontBoundingBoxAscent:0}),e},In=(n,t)=>{const e=Pt();e.font=`${t.fontSize}px ${t.fontFamily}`;const s=e.measureText(n);return{width:s.width,height:s.fontBoundingBoxAscent+s.fontBoundingBoxDescent,fontBoundingBoxAscent:s.fontBoundingBoxAscent}};x.GeoPath=nt,x.Matrix=z,x.applyInverseMatrix=Wt,x.applyMatrix=it,x.applySizeToTransform=qt,x.boxToRect=Gt,x.calcGlyphInfos=vn,x.calcRectBbox=tn,x.calcTextSize=In,x.checkTransformFlip=Rt,x.closestPtOnLine=tt,x.commandsToStr=un,x.deg2Rad=Tt,x.deletePathSegAndHeal=an,x.distance=A,x.ellipseToPathCmds=en,x.getAngleBetweenVec=at,x.getBezierPoint=J,x.getLineIntersection=bt,x.getLineJointRoundArc=Ct,x.getPerpendicularPoints=Yt,x.getPointsBbox=ct,x.getPolarTrackSnapPt=Mt,x.getRectApplyMatrix=Kt,x.getRectByTwoPoint=gt,x.getRegularPolygon=xn,x.getRotatedRectByTwoPoint=Vt,x.getScaleMatrix=ft,x.getStar=bn,x.getSweepAngle=H,x.getTransformAngle=Lt,x.getTransformedSize=pt,x.identityMatrix=Nt,x.insertPathSeg=hn,x.invertMatrix=xt,x.isBoxContain=Qt,x.isBoxIntersect=Jt,x.isPointEqual=yt,x.isPointInBox=wt,x.isPointInCircle=nn,x.isPointInConvexPolygon=fn,x.isPointInPolygon=dn,x.isPointInRoundRect=Et,x.isPointInTransformedRect=Ft,x.isRectContain=kt,x.isRectIntersect=Dt,x.isZeroPoint=Z,x.lerp=q,x.lerpNum=U,x.mergeBoxes=Ut,x.mergeRect=_t,x.multiplyMatrix=lt,x.normalizeDegree=At,x.normalizeRadian=ht,x.normalizeRect=Ot,x.normalizeVec=G,x.offsetRect=jt,x.pointAdd=W,x.pointMid=st,x.pointSub=_,x.rad2Deg=Bt,x.recomputeTransformRect=Ht,x.rectToBox=rt,x.rectToMidPoints=$t,x.rectToVertices=ot,x.resizeLine=pn,x.resizeRect=Mn,x.roundPolygon=mn,x.roundRectToPathCmds=Zt,x.simplePath=cn,x.splitBezierSegs=ut,x.transformRotate=dt,Object.defineProperty(x,Symbol.toStringTag,{value:"Module"})});
