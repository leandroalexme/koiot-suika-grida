{
  "version": 3,
  "sources": ["../src/geo/geo_matrix_class.ts", "../src/geo/geo_angle.ts", "../src/geo/geo_point.ts", "../src/geo/geo_bezier.ts", "../src/geo/geo_matrix.ts", "../src/transform.ts", "../src/geo/constant.ts", "../src/geo/geo_rect.ts", "../src/geo/geo_box.ts", "../src/geo/geo_circle.ts", "../src/geo/geo_ellipse.ts", "../src/geo/geo_line.ts", "../src/geo/geo_path.ts", "../src/geo/geo_bezier_class.ts", "../src/geo/geo_path_class.ts", "../src/geo/geo_arc.ts", "../src/geo/geo_polygon.ts", "../src/geo/geo_resize_line.ts", "../src/geo/geo_resize_rect/geo_resize_rect.ts", "../src/geo/geo_star.ts", "../src/geo/geo_text.ts"],
  "sourcesContent": ["import { type IMatrixArr, type IPoint } from '../type';\n\n/**\n * Modified from\n *\n * pixi.js 8.1.5\n * https://github.com/pixijs/pixijs\n *\n *\n * A fast matrix for 2D transformations.\n * ```js\n * | a | c | tx|\n * | b | d | ty|\n * | 0 | 0 | 1 |\n * ```\n */\nexport class Matrix {\n  /** @default 1 */\n  public a: number;\n\n  /** @default 0 */\n  public b: number;\n\n  /** @default 0 */\n  public c: number;\n\n  /** @default 1 */\n  public d: number;\n\n  /** @default 0 */\n  public tx: number;\n\n  /** @default 0 */\n  public ty: number;\n\n  /**\n   * @param a - x scale\n   * @param b - y skew\n   * @param c - x skew\n   * @param d - y scale\n   * @param tx - x translation\n   * @param ty - y translation\n   */\n  constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.d = d;\n    this.tx = tx;\n    this.ty = ty;\n  }\n\n  /**\n   * Sets the matrix properties.\n   * @param a - Matrix component\n   * @param b - Matrix component\n   * @param c - Matrix component\n   * @param d - Matrix component\n   * @param tx - Matrix component\n   * @param ty - Matrix component\n   * @returns This matrix. Good for chaining method calls.\n   */\n  public set(\n    a: number,\n    b: number,\n    c: number,\n    d: number,\n    tx: number,\n    ty: number,\n  ): this {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.d = d;\n    this.tx = tx;\n    this.ty = ty;\n\n    return this;\n  }\n\n  /**\n   * Creates an array from the current Matrix object.\n   * @returns The newly created array which contains the matrix\n   */\n  public getArray(): IMatrixArr {\n    return [this.a, this.b, this.c, this.d, this.tx, this.ty];\n  }\n\n  /**\n   * Get a new position with the current transformation applied.\n   * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)\n   * @param pos - The origin\n   * @returns {IPoint} The new point, transformed through this matrix\n   */\n  public apply(pos: IPoint): IPoint {\n    const x = pos.x;\n    const y = pos.y;\n    return {\n      x: this.a * x + this.c * y + this.tx,\n      y: this.b * x + this.d * y + this.ty,\n    };\n  }\n\n  /**\n   * Get a new position with the inverse of the current transformation applied.\n   * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)\n   * @param pos - The origin\n   * @returns {IPoint} The new point, inverse-transformed through this matrix\n   */\n  public applyInverse(pos: IPoint): IPoint {\n    const a = this.a;\n    const b = this.b;\n    const c = this.c;\n    const d = this.d;\n    const tx = this.tx;\n    const ty = this.ty;\n\n    const id = 1 / (a * d + c * -b);\n\n    const x = pos.x;\n    const y = pos.y;\n\n    return {\n      x: d * id * x + -c * id * y + (ty * c - tx * d) * id,\n      y: a * id * y + -b * id * x + (-ty * a + tx * b) * id,\n    };\n  }\n\n  /**\n   * Translates the matrix on the x and y.\n   * @param x - How much to translate x by\n   * @param y - How much to translate y by\n   * @returns This matrix. Good for chaining method calls.\n   */\n  public translate(x: number, y: number): this {\n    this.tx += x;\n    this.ty += y;\n\n    return this;\n  }\n\n  /**\n   * Applies a scale transformation to the matrix.\n   * @param x - The amount to scale horizontally\n   * @param y - The amount to scale vertically\n   * @returns This matrix. Good for chaining method calls.\n   */\n  public scale(x: number, y: number): this {\n    this.a *= x;\n    this.d *= y;\n    this.c *= x;\n    this.b *= y;\n    this.tx *= x;\n    this.ty *= y;\n\n    return this;\n  }\n\n  /**\n   * Applies a rotation transformation to the matrix.\n   * @param angle - The angle in radians.\n   * @returns This matrix. Good for chaining method calls.\n   */\n  public rotate(angle: number): this {\n    const cos = Math.cos(angle);\n    const sin = Math.sin(angle);\n\n    const a1 = this.a;\n    const c1 = this.c;\n    const tx1 = this.tx;\n\n    this.a = a1 * cos - this.b * sin;\n    this.b = a1 * sin + this.b * cos;\n    this.c = c1 * cos - this.d * sin;\n    this.d = c1 * sin + this.d * cos;\n    this.tx = tx1 * cos - this.ty * sin;\n    this.ty = tx1 * sin + this.ty * cos;\n\n    return this;\n  }\n\n  /**\n   * Appends the given Matrix to this Matrix.\n   * @param matrix - The matrix to append.\n   * @returns This matrix. Good for chaining method calls.\n   */\n  public append(matrix: Matrix): this {\n    const a1 = this.a;\n    const b1 = this.b;\n    const c1 = this.c;\n    const d1 = this.d;\n\n    this.a = matrix.a * a1 + matrix.b * c1;\n    this.b = matrix.a * b1 + matrix.b * d1;\n    this.c = matrix.c * a1 + matrix.d * c1;\n    this.d = matrix.c * b1 + matrix.d * d1;\n\n    this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;\n    this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;\n\n    return this;\n  }\n\n  /**\n   * Appends two matrix's and sets the result to this matrix. AB = A * B\n   * @param a - The matrix to append.\n   * @param b - The matrix to append.\n   * @returns This matrix. Good for chaining method calls.\n   */\n  public appendFrom(a: Matrix, b: Matrix): this {\n    const a1 = a.a;\n    const b1 = a.b;\n    const c1 = a.c;\n    const d1 = a.d;\n    const tx = a.tx;\n    const ty = a.ty;\n\n    const a2 = b.a;\n    const b2 = b.b;\n    const c2 = b.c;\n    const d2 = b.d;\n\n    this.a = a1 * a2 + b1 * c2;\n    this.b = a1 * b2 + b1 * d2;\n    this.c = c1 * a2 + d1 * c2;\n    this.d = c1 * b2 + d1 * d2;\n    this.tx = tx * a2 + ty * c2 + b.tx;\n    this.ty = tx * b2 + ty * d2 + b.ty;\n\n    return this;\n  }\n\n  /**\n   * Prepends the given Matrix to this Matrix.\n   * @param matrix - The matrix to prepend\n   * @returns This matrix. Good for chaining method calls.\n   */\n  public prepend(matrix: Matrix): this {\n    const tx1 = this.tx;\n\n    if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {\n      const a1 = this.a;\n      const c1 = this.c;\n\n      this.a = a1 * matrix.a + this.b * matrix.c;\n      this.b = a1 * matrix.b + this.b * matrix.d;\n      this.c = c1 * matrix.a + this.d * matrix.c;\n      this.d = c1 * matrix.b + this.d * matrix.d;\n    }\n\n    this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;\n    this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;\n\n    return this;\n  }\n\n  /**\n   * Inverts this matrix\n   * @returns This matrix. Good for chaining method calls.\n   */\n  public invert(): this {\n    const a1 = this.a;\n    const b1 = this.b;\n    const c1 = this.c;\n    const d1 = this.d;\n    const tx1 = this.tx;\n    const n = a1 * d1 - b1 * c1;\n\n    this.a = d1 / n;\n    this.b = -b1 / n;\n    this.c = -c1 / n;\n    this.d = a1 / n;\n    this.tx = (c1 * this.ty - d1 * tx1) / n;\n    this.ty = -(a1 * this.ty - b1 * tx1) / n;\n\n    return this;\n  }\n\n  /** Checks if this matrix is an identity matrix */\n  public isIdentity(): boolean {\n    return (\n      this.a === 1 &&\n      this.b === 0 &&\n      this.c === 0 &&\n      this.d === 1 &&\n      this.tx === 0 &&\n      this.ty === 0\n    );\n  }\n\n  /**\n   * Resets this Matrix to an identity (default) matrix.\n   * @returns This matrix. Good for chaining method calls.\n   */\n  public identity(): this {\n    this.a = 1;\n    this.b = 0;\n    this.c = 0;\n    this.d = 1;\n    this.tx = 0;\n    this.ty = 0;\n\n    return this;\n  }\n\n  /**\n   * Creates a new Matrix object with the same values as this one.\n   * @returns A copy of this matrix. Good for chaining method calls.\n   */\n  public clone(): Matrix {\n    const matrix = new Matrix();\n\n    matrix.a = this.a;\n    matrix.b = this.b;\n    matrix.c = this.c;\n    matrix.d = this.d;\n    matrix.tx = this.tx;\n    matrix.ty = this.ty;\n\n    return matrix;\n  }\n\n  /**\n   * Changes the values of the given matrix to be the same as the ones in this matrix\n   * @param matrix - The matrix to copy to.\n   * @returns The matrix given in parameter with its values updated.\n   */\n  public copyTo(matrix: Matrix): Matrix {\n    matrix.a = this.a;\n    matrix.b = this.b;\n    matrix.c = this.c;\n    matrix.d = this.d;\n    matrix.tx = this.tx;\n    matrix.ty = this.ty;\n\n    return matrix;\n  }\n\n  /**\n   * Changes the values of the matrix to be the same as the ones in given matrix\n   * @param matrix - The matrix to copy from.\n   * @returns this\n   */\n  public copyFrom(matrix: Matrix): this {\n    this.a = matrix.a;\n    this.b = matrix.b;\n    this.c = matrix.c;\n    this.d = matrix.d;\n    this.tx = matrix.tx;\n    this.ty = matrix.ty;\n\n    return this;\n  }\n\n  /**\n   * check to see if two matrices are the same\n   * @param matrix - The matrix to compare to.\n   */\n  public equals(matrix: Matrix) {\n    return (\n      matrix.a === this.a &&\n      matrix.b === this.b &&\n      matrix.c === this.c &&\n      matrix.d === this.d &&\n      matrix.tx === this.tx &&\n      matrix.ty === this.ty\n    );\n  }\n\n  // #if _DEBUG\n  public toString(): string {\n    return `[Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;\n  }\n  // #endif\n}\n", "import { type IMatrixArr, type IPoint } from '../type';\nimport { Matrix } from './geo_matrix_class';\n\nconst DOUBLE_PI = Math.PI * 2;\n\nexport function rad2Deg(radian: number) {\n  return (radian * 180) / Math.PI;\n}\n\nexport function deg2Rad(degree: number) {\n  return (degree * Math.PI) / 180;\n}\n\n/**\n * normalize radian, make it in [0, Math.PI * 2)\n */\nexport const normalizeRadian = (radian: number): number => {\n  radian = radian % DOUBLE_PI;\n  if (radian < 0) {\n    radian += DOUBLE_PI;\n  }\n  return radian;\n};\n\n/**\n * normalize degree, make it in [0, 360)\n */\nexport const normalizeDegree = (degree: number): number => {\n  degree = degree % 360;\n  if (degree < 0) {\n    degree += 360;\n  }\n  return degree;\n};\n\n/** get angle between two vectors */\nexport const getAngleBetweenVec = (a: IPoint, b: IPoint) => {\n  const dot = a.x * b.x + a.y * b.y;\n  const d = Math.sqrt(a.x * a.x + a.y * a.y) * Math.sqrt(b.x * b.x + b.y * b.y);\n  let cosTheta = dot / d;\n\n  if (cosTheta > 1) {\n    cosTheta = 1;\n  } else if (cosTheta < -1) {\n    cosTheta = -1;\n  }\n  return Math.acos(cosTheta);\n};\n\n/**\n * get sweep angle from vector a to vector b\n * direction is clockwise\n */\nexport const getSweepAngle = (\n  a: IPoint,\n  b: IPoint,\n  anticlockwise?: boolean,\n) => {\n  // \u70B9\u4E58\u6C42\u5939\u89D2\n  const dot = a.x * b.x + a.y * b.y;\n  const d = Math.sqrt(a.x * a.x + a.y * a.y) * Math.sqrt(b.x * b.x + b.y * b.y);\n  let cosTheta = dot / d;\n  if (cosTheta > 1) {\n    cosTheta = 1;\n  } else if (cosTheta < -1) {\n    cosTheta = -1;\n  }\n\n  let theta = Math.acos(cosTheta);\n  const cross = a.x * b.y - a.y * b.x;\n  const reverse = anticlockwise ? cross > 0 : cross < 0;\n  if (reverse) {\n    theta = DOUBLE_PI - theta;\n  }\n\n  return theta;\n};\n\n/**\n * get angle of transform matrix\n */\nexport const getTransformAngle = (\n  transform: IMatrixArr,\n  angleBase = { x: 0, y: -1 },\n) => {\n  const tf = new Matrix(\n    transform[0],\n    transform[1],\n    transform[2],\n    transform[3],\n    0,\n    0,\n  );\n  const angleVec = tf.apply(angleBase);\n  return getSweepAngle(angleBase, angleVec);\n};\n\nexport const checkTransformFlip = (transform: IMatrixArr) => {\n  return transform[0] * transform[3] - transform[1] * transform[2] < 0;\n};\n", "import { type IPoint } from '../type';\n\nexport const pointMid = (p1: IPoint, p2: IPoint) => {\n  return {\n    x: (p1.x + p2.x) / 2,\n    y: (p1.y + p2.y) / 2,\n  };\n};\n\nexport const pointAdd = (p1: IPoint, p2: IPoint) => {\n  return {\n    x: p1.x + p2.x,\n    y: p1.y + p2.y,\n  };\n};\n\nexport const pointSub = (p1: IPoint, p2: IPoint): IPoint => {\n  return {\n    x: p1.x - p2.x,\n    y: p1.y - p2.y,\n  };\n};\n\nexport const isZeroPoint = (p: IPoint) => {\n  return p.x === 0 && p.y === 0;\n};\n\nconst TOL = 0.0000000001;\n\nexport const isPointEqual = (p1: IPoint, p2: IPoint, tol = TOL) => {\n  return Math.abs(p1.x - p2.x) < tol && Math.abs(p1.y - p2.y) < tol;\n};\n\nexport const distance = (p1: IPoint, p2: IPoint) => {\n  return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));\n};\n\nexport const lerpNum = (start: number, end: number, t: number): number => {\n  return start * (1 - t) + end * t;\n};\n\nexport const lerp = (start: IPoint, end: IPoint, t: number) => {\n  return {\n    x: lerpNum(start.x, end.x, t),\n    y: lerpNum(start.y, end.y, t),\n  };\n};\n\nexport const normalizeVec = (p: IPoint) => {\n  const len = Math.sqrt(p.x * p.x + p.y * p.y);\n  return {\n    x: p.x / len,\n    y: p.y / len,\n  };\n};\n\n/**\n * Given a point on a line segment,\n * find two points that are perpendicular to the line segment and at a given distance\n */\nexport const getPerpendicularPoints = (\n  line: [IPoint, IPoint],\n  p: IPoint,\n  distance: number,\n) => {\n  const vec = pointSub(line[1], line[0]);\n  const perpendicularVec = {\n    x: -vec.y,\n    y: vec.x,\n  };\n  const unitVec = normalizeVec(perpendicularVec);\n  const p1 = {\n    x: p.x + unitVec.x * distance,\n    y: p.y + unitVec.y * distance,\n  };\n  const p2 = {\n    x: p.x - unitVec.x * distance,\n    y: p.y - unitVec.y * distance,\n  };\n  return [p1, p2];\n};\n", "import { type IPoint, type ISegment } from '../type';\nimport { lerp, pointAdd, pointSub } from './geo_point';\n\nexport const getBezierPoint = (points: IPoint[], t: number) => {\n  if (points.length === 4) {\n    const [p1, cp1, cp2, p2] = points;\n    const t2 = t * t;\n    const ct = 1 - t;\n    const ct2 = ct * ct;\n    const a = ct2 * ct;\n    const b = 3 * t * ct2;\n    const c = 3 * t2 * ct;\n    const d = t2 * t;\n\n    return {\n      x: a * p1.x + b * cp1.x + c * cp2.x + d * p2.x,\n      y: a * p1.y + b * cp1.y + c * cp2.y + d * p2.y,\n    };\n  }\n\n  while (points.length > 1) {\n    const nextPts = [];\n    for (let i = 0, size = points.length - 1; i < size; i++) {\n      nextPts.push(lerp(points[i], points[i + 1], t));\n    }\n    points = nextPts;\n  }\n  return points[0];\n};\n\nexport const splitBezierSegs = (\n  seg1: ISegment,\n  seg2: ISegment,\n  t: number,\n): [ISegment, ISegment, ISegment] => {\n  const p1 = seg1.point;\n  const p2 = seg2.point;\n  const cp1 = pointAdd(seg1.point, seg1.out);\n  const cp2 = pointAdd(seg2.point, seg2.in);\n\n  const a = lerp(p1, cp1, t);\n  const b = lerp(cp1, cp2, t);\n  const c = lerp(cp2, p2, t);\n\n  const d = lerp(a, b, t);\n  const e = lerp(b, c, t);\n\n  const f = lerp(d, e, t);\n\n  return [\n    {\n      point: seg1.point,\n      in: seg1.in,\n      out: pointSub(a, seg1.point),\n    },\n    {\n      point: f,\n      in: pointSub(d, f),\n      out: pointSub(e, f),\n    },\n    {\n      point: seg2.point,\n      in: pointSub(c, seg2.point),\n      out: seg2.out,\n    },\n  ];\n};\n", "import { type IMatrixArr, type IPoint, type ITransformRect } from '../type';\n\nexport const identityMatrix = (): IMatrixArr => {\n  return [1, 0, 0, 1, 0, 0];\n};\n\nexport const multiplyMatrix = (m1: IMatrixArr, m2: IMatrixArr): IMatrixArr => {\n  const a1 = m1[0];\n  const b1 = m1[1];\n  const c1 = m1[2];\n  const d1 = m1[3];\n\n  return [\n    m2[0] * a1 + m2[1] * c1,\n    m2[0] * b1 + m2[1] * d1,\n    m2[2] * a1 + m2[3] * c1,\n    m2[2] * b1 + m2[3] * d1,\n    m2[4] * a1 + m2[5] * c1 + m1[4],\n    m2[4] * b1 + m2[5] * d1 + m1[5],\n  ];\n};\n\nexport const applyMatrix = (tf: IMatrixArr, pt: IPoint): IPoint => {\n  return {\n    x: pt.x * tf[0] + pt.y * tf[2] + tf[4],\n    y: pt.x * tf[1] + pt.y * tf[3] + tf[5],\n  };\n};\n\nexport const applyInverseMatrix = (tf: IMatrixArr, pt: IPoint): IPoint => {\n  return applyMatrix(invertMatrix(tf), pt);\n};\n\nexport const invertMatrix = (tf: IMatrixArr): IMatrixArr => {\n  const a1 = tf[0];\n  const b1 = tf[1];\n  const c1 = tf[2];\n  const d1 = tf[3];\n  const tx1 = tf[4];\n  const n = a1 * d1 - b1 * c1;\n\n  return [\n    d1 / n,\n    -b1 / n,\n    -c1 / n,\n    a1 / n,\n    (c1 * tf[5] - d1 * tx1) / n,\n    -(a1 * tf[5] - b1 * tx1) / n,\n  ];\n};\n\nexport const getScaleMatrix = (sx: number, sy: number): IMatrixArr => {\n  return [sx, 0, 0, sy, 0, 0];\n};\n\nexport const applySizeToTransform = (\n  transformRect: ITransformRect,\n): IMatrixArr => {\n  return multiplyMatrix(\n    transformRect.transform,\n    getScaleMatrix(transformRect.width, transformRect.height),\n  );\n};\n", "import { type IPoint } from './type';\n\nexport const transformRotate = (\n  x: number,\n  y: number,\n  radian: number,\n  cx: number,\n  cy: number,\n): IPoint => {\n  if (!radian) {\n    return { x, y };\n  }\n  const cos = Math.cos(radian);\n  const sin = Math.sin(radian);\n  return {\n    x: (x - cx) * cos - (y - cy) * sin + cx,\n    y: (x - cx) * sin + (y - cy) * cos + cy,\n  };\n};\n", "export const K = 0.5522847498307936;\n", "import { transformRotate } from '../transform';\nimport {\n  type IBox,\n  type IMatrixArr,\n  type IPathCommand,\n  type IPoint,\n  type IRect,\n  type ISize,\n  type ITransformRect,\n} from '../type';\nimport { K } from './constant';\nimport { normalizeRadian } from './geo_angle';\nimport { Matrix } from './geo_matrix_class';\nimport { distance } from './geo_point';\n\nexport const getRectByTwoPoint = (point1: IPoint, point2: IPoint): IRect => {\n  return {\n    x: Math.min(point1.x, point2.x),\n    y: Math.min(point1.y, point2.y),\n    width: Math.abs(point1.x - point2.x),\n    height: Math.abs(point1.y - point2.y),\n  };\n};\n\nexport const isPointInTransformedRect = (\n  point: IPoint,\n  rect: {\n    width: number;\n    height: number;\n    transform?: IMatrixArr;\n  },\n  tol = 0,\n) => {\n  if (rect.transform) {\n    const matrix = new Matrix(...rect.transform);\n    point = matrix.applyInverse(point);\n  }\n\n  return (\n    point.x >= -tol &&\n    point.y >= -tol &&\n    point.x <= rect.width + tol &&\n    point.y <= rect.height + tol\n  );\n};\n\nexport const isPointInRoundRect = (\n  point: IPoint,\n  rect: IRect,\n  cornerRadii: number[],\n  padding = 0,\n) => {\n  const x = rect.x - padding;\n  const y = rect.y - padding;\n  const width = rect.width + padding * 2;\n  const height = rect.height + padding * 2;\n\n  if (\n    point.x >= x &&\n    point.y >= y &&\n    point.x <= x + width &&\n    point.y <= y + height\n  ) {\n    if (point.x <= x + cornerRadii[0] && point.y <= y + cornerRadii[0]) {\n      return (\n        (point.x - x - cornerRadii[0]) ** 2 +\n          (point.y - y - cornerRadii[0]) ** 2 <=\n        cornerRadii[0] ** 2\n      );\n    } else if (\n      point.x >= x + width - cornerRadii[1] &&\n      point.y <= y + cornerRadii[1]\n    ) {\n      return (\n        (point.x - x - width + cornerRadii[1]) ** 2 +\n          (point.y - y - cornerRadii[1]) ** 2 <=\n        cornerRadii[1] ** 2\n      );\n    } else if (\n      point.x >= x + width - cornerRadii[2] &&\n      point.y >= y + height - cornerRadii[2]\n    ) {\n      return (\n        (point.x - x - width + cornerRadii[2]) ** 2 +\n          (point.y - y - height + cornerRadii[2]) ** 2 <=\n        cornerRadii[2] ** 2\n      );\n    } else if (\n      point.x <= x + cornerRadii[3] &&\n      point.y >= y + height - cornerRadii[3]\n    ) {\n      return (\n        (point.x - x - cornerRadii[3]) ** 2 +\n          (point.y - y - height + cornerRadii[3]) ** 2 <=\n        cornerRadii[3] ** 2\n      );\n    } else {\n      return true;\n    }\n  } else {\n    return false;\n  }\n};\n\n/**\n * normalize rect,\n * width or height may be negative\n */\nexport const normalizeRect = ({ x, y, width, height }: IRect): IRect => {\n  const x2 = x + width;\n  const y2 = y + height;\n  return getRectByTwoPoint({ x, y }, { x: x2, y: y2 });\n};\n\n/**\n * get merged rect from rects\n */\nexport const mergeRect = (...rects: IRect[]): IRect => {\n  if (rects.length === 0) {\n    throw new Error('the count of rect can not be 0');\n  }\n\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  for (const rect of rects) {\n    minX = Math.min(minX, rect.x);\n    minY = Math.min(minY, rect.y);\n    maxX = Math.max(maxX, rect.x + rect.width);\n    maxY = Math.max(maxY, rect.y + rect.height);\n  }\n\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY,\n  };\n};\n\nexport const isRectIntersect = (rect1: IRect, rect2: IRect) => {\n  return (\n    rect1.x <= rect2.x + rect2.width &&\n    rect1.x + rect1.width >= rect2.x &&\n    rect1.y <= rect2.y + rect2.height &&\n    rect1.y + rect1.height >= rect2.y\n  );\n};\n\n/** whether rect1 contains rect2 */\nexport const isRectContain = (rect1: IRect, rect2: IRect) => {\n  return (\n    rect1.x <= rect2.x &&\n    rect1.y <= rect2.y &&\n    rect1.x + rect1.width >= rect2.x + rect2.width &&\n    rect1.y + rect1.height >= rect2.y + rect2.height\n  );\n};\n\nexport const offsetRect = (rect: IRect, padding: number | number[]) => {\n  if (typeof padding === 'number') {\n    padding = [padding, padding, padding, padding];\n  }\n  const { x, y, width, height } = rect;\n\n  return {\n    x: x - padding[3],\n    y: y - padding[0],\n    width: width + padding[1] + padding[3],\n    height: height + padding[0] + padding[2],\n  };\n};\n\n/** get mid-point of each segment */\nexport const rectToMidPoints = (rect: IRect) => {\n  const { x, y, width, height } = rect;\n  const halfWidth = width / 2;\n  const halfHeight = height / 2;\n  return [\n    { x: x + halfWidth, y },\n    { x: x + width, y: y + halfHeight },\n    { x: x + halfWidth, y: y + height },\n    { x, y: y + halfHeight },\n  ];\n};\n\n/**\n * line -> rect with rotation, and height is 0\n */\nexport const getRotatedRectByTwoPoint = (\n  point1: IPoint,\n  point2: IPoint,\n): IRect & { rotation: number } => {\n  const { x, y } = point1;\n  const width = point2.x - point1.x;\n  const height = point2.y - point1.y;\n  const rotation = normalizeRadian(Math.atan2(height, width));\n  const cx = x + width / 2;\n  const cy = y + height / 2;\n  const p = transformRotate(x, y, -rotation, cx, cy);\n\n  return {\n    x: p.x,\n    y: p.y,\n    width: Math.sqrt(width * width + height * height),\n    height: 0,\n    rotation,\n  };\n};\n\n/**\n * Convert a rectangle to an array of vertices\n */\nexport const rectToVertices = (rect: IRect, tf?: IMatrixArr): IPoint[] => {\n  const { x, y, width, height } = rect;\n  let pts = [\n    { x, y },\n    { x: x + width, y },\n    { x: x + width, y: y + height },\n    { x, y: y + height },\n  ];\n  if (tf) {\n    const matrix = new Matrix(...tf);\n    pts = pts.map((point) => {\n      const pt = matrix.apply(point);\n      return { x: pt.x, y: pt.y };\n    });\n  }\n  return pts;\n};\n\n/**\n * get bbox after transform\n * then get the rect of the bbox\n */\nexport const getRectApplyMatrix = (rect: ITransformRect) => {\n  const pts = rectToVertices(\n    {\n      x: 0,\n      y: 0,\n      width: rect.width,\n      height: rect.height,\n    },\n    rect.transform,\n  );\n\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n\n  for (const pt of pts) {\n    minX = Math.min(minX, pt.x);\n    minY = Math.min(minY, pt.y);\n    maxX = Math.max(maxX, pt.x);\n    maxY = Math.max(maxY, pt.y);\n  }\n\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY,\n  };\n};\n\nexport const getTransformedSize = (rect: ITransformRect): ISize => {\n  const tf = new Matrix(\n    rect.transform[0],\n    rect.transform[1],\n    rect.transform[2],\n    rect.transform[3],\n    0,\n    0,\n  );\n  const rightTop = tf.apply({ x: rect.width, y: 0 });\n  const leftBottom = tf.apply({ x: 0, y: rect.height });\n  const zero = { x: 0, y: 0 };\n  return {\n    width: distance(rightTop, zero),\n    height: distance(leftBottom, zero),\n  };\n};\n\n/**\n * \u91CD\u65B0\u8BA1\u7B97 width\u3001height \u548C transform\n * \u786E\u4FDD transform \u524D\u540E\u7684 size \u76F8\u540C\n */\nexport const recomputeTransformRect = (\n  rect: ITransformRect,\n): ITransformRect => {\n  const newSize = getTransformedSize(rect);\n  const scaleX = newSize.width ? rect.width / newSize.width : 1;\n  const scaleY = newSize.height ? rect.height / newSize.height : 1;\n  const scaleMatrix = new Matrix().scale(scaleX, scaleY);\n\n  const tf = new Matrix(...rect.transform).append(scaleMatrix);\n  return {\n    width: newSize.width,\n    height: newSize.height,\n    transform: tf.getArray(),\n  };\n};\n\nexport const rectToBox = (rect: IRect): IBox => {\n  return {\n    minX: rect.x,\n    minY: rect.y,\n    maxX: rect.x + rect.width,\n    maxY: rect.y + rect.height,\n  };\n};\n\nexport const boxToRect = (box: IBox): IRect => {\n  return {\n    x: box.minX,\n    y: box.minY,\n    width: box.maxX - box.minX,\n    height: box.maxY - box.minY,\n  };\n};\n\nexport const roundRectToPathCmds = (\n  rect: IRect,\n  cornerRadius = 0,\n): IPathCommand[] => {\n  const { minX, minY, maxX, maxY } = rectToBox(rect);\n  if (cornerRadius <= 0) {\n    return [\n      { type: 'M', points: [{ x: minX, y: minY }] },\n      { type: 'L', points: [{ x: maxX, y: minY }] },\n      { type: 'L', points: [{ x: maxX, y: maxY }] },\n      { type: 'L', points: [{ x: minX, y: maxY }] },\n      { type: 'Z', points: [] },\n    ];\n  }\n\n  const halfWidth = rect.width / 2;\n  const halfHeight = rect.height / 2;\n  const r = Math.min(cornerRadius, halfWidth, halfHeight);\n  const isFullWidth = r === halfWidth;\n  const isFullHeight = r === halfHeight;\n\n  const lx = r * K;\n  const ly = r * K;\n\n  const commands: IPathCommand[] = [\n    // left top\n    { type: 'M', points: [{ x: minX, y: minY + r }] },\n    {\n      type: 'C',\n      points: [\n        { x: minX, y: minY + r - ly },\n        { x: minX + r - lx, y: minY },\n        { x: minX + r, y: minY },\n      ],\n    },\n  ];\n  // top line (skip if full width)\n  if (!isFullWidth) {\n    commands.push({\n      type: 'L',\n      points: [{ x: maxX - r, y: minY }],\n    });\n  }\n  // right top\n  commands.push({\n    type: 'C',\n    points: [\n      { x: maxX - r + lx, y: minY },\n      { x: maxX, y: minY + r - ly },\n      { x: maxX, y: minY + r },\n    ],\n  });\n  // right line (skip if full height)\n  if (!isFullHeight) {\n    commands.push({\n      type: 'L',\n      points: [{ x: maxX, y: maxY - r }],\n    });\n  }\n  // right bottom\n  commands.push({\n    type: 'C',\n    points: [\n      { x: maxX, y: maxY - r + ly },\n      { x: maxX - r + lx, y: maxY },\n      { x: maxX - r, y: maxY },\n    ],\n  });\n  // bottom line (skip if full width)\n  if (!isFullWidth) {\n    commands.push({\n      type: 'L',\n      points: [{ x: minX + r, y: maxY }],\n    });\n  }\n  // left bottom\n  commands.push({\n    type: 'C',\n    points: [\n      { x: minX + r - lx, y: maxY },\n      { x: minX, y: maxY - r + ly },\n      { x: minX, y: maxY - r },\n    ],\n  });\n  // left line (skip if full height)\n  if (!isFullHeight) {\n    commands.push({\n      type: 'L',\n      points: [{ x: minX, y: minY + r }],\n    });\n  }\n  commands.push({\n    type: 'Z',\n    points: [],\n  });\n\n  return commands;\n};\n", "import { type IBox, type IPoint, type ITransformRect } from '../type';\nimport { applyMatrix } from './geo_matrix';\nimport { rectToVertices } from './geo_rect';\n\nexport const isPointInBox = (box: IBox, point: IPoint, tol = 0) => {\n  return (\n    point.x >= box.minX - tol &&\n    point.y >= box.minY - tol &&\n    point.x <= box.maxX + tol &&\n    point.y <= box.maxY + tol\n  );\n};\n\n/**\n * get merged rect from rects\n */\nexport const mergeBoxes = (boxes: IBox[]): IBox => {\n  if (boxes.length === 0) {\n    throw new Error('the count of boxes can not be 0');\n  }\n\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  for (const box of boxes) {\n    minX = Math.min(minX, box.minX);\n    minY = Math.min(minY, box.minY);\n    maxX = Math.max(maxX, box.maxX);\n    maxY = Math.max(maxY, box.maxY);\n  }\n\n  return {\n    minX,\n    minY,\n    maxX,\n    maxY,\n  };\n};\n\nexport const isBoxIntersect = (box1: IBox, box2: IBox) => {\n  return (\n    box1.minX <= box2.maxX &&\n    box1.maxX >= box2.minX &&\n    box1.minY <= box2.maxY &&\n    box1.maxY >= box2.minY\n  );\n};\n\n/** whether box1 contains box2 */\nexport const isBoxContain = (box1: IBox, box2: IBox) => {\n  return (\n    box1.minX <= box2.minX &&\n    box1.minY <= box2.minY &&\n    box1.maxX >= box2.maxX &&\n    box1.maxY >= box2.maxY\n  );\n};\n\nexport const getPointsBbox = (points: IPoint[]): IBox => {\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n\n  for (const pt of points) {\n    minX = Math.min(minX, pt.x);\n    minY = Math.min(minY, pt.y);\n    maxX = Math.max(maxX, pt.x);\n    maxY = Math.max(maxY, pt.y);\n  }\n\n  return {\n    minX,\n    minY,\n    maxX,\n    maxY,\n  };\n};\n\n/**\n * calculate AABB\n */\nexport const calcRectBbox = (\n  transformRect: ITransformRect,\n  paddingBeforeTransform?: number,\n): Readonly<IBox> => {\n  let x = 0;\n  let y = 0;\n  let width = transformRect.width;\n  let height = transformRect.height;\n  if (paddingBeforeTransform) {\n    x -= paddingBeforeTransform;\n    y -= paddingBeforeTransform;\n    width += paddingBeforeTransform * 2;\n    height += paddingBeforeTransform * 2;\n  }\n  const tf = transformRect.transform;\n  const vertices = rectToVertices({\n    x,\n    y,\n    width,\n    height,\n  }).map((item) => {\n    return applyMatrix(tf, item);\n  });\n\n  return getPointsBbox(vertices);\n};\n", "import { type ICircle, type IPoint } from '../type';\n\nexport const isPointInCircle = (point: IPoint, circle: ICircle) => {\n  const dx = point.x - circle.x;\n  const dy = point.y - circle.y;\n  const dSquare = dx * dx + dy * dy;\n  return dSquare <= circle.radius * circle.radius;\n};\n", "import { type IPathCommand, type IRect } from '../type';\nimport { rectToBox } from './geo_rect';\n\nexport const ellipseToPathCmds = (rect: IRect): IPathCommand[] => {\n  const k = 0.5522847498307936;\n\n  const { minX, minY, maxX, maxY } = rectToBox(rect);\n  const midX = (minX + maxX) / 2;\n  const midY = (minY + maxY) / 2;\n\n  const rx = rect.width / 2;\n  const ry = rect.height / 2;\n\n  const lx = rx * k;\n  const ly = ry * k;\n\n  // clockwise, starting from the right vertex\n  return [\n    { type: 'M', points: [{ x: maxX, y: midY }] },\n    // right bottom\n    {\n      type: 'C',\n      points: [\n        { x: maxX, y: midY + ly },\n        { x: midX + lx, y: maxY },\n        { x: midX, y: maxY },\n      ],\n    },\n    // left bottom\n    {\n      type: 'C',\n      points: [\n        { x: midX - lx, y: maxY },\n        { x: minX, y: midY + ly },\n        { x: minX, y: midY },\n      ],\n    },\n    // left top\n    {\n      type: 'C',\n      points: [\n        { x: minX, y: midY - ly },\n        { x: midX - lx, y: minY },\n        { x: midX, y: minY },\n      ],\n    },\n    // right top\n    {\n      type: 'C',\n      points: [\n        { x: maxX, y: midY - ly },\n        { x: midX + lx, y: minY },\n        { x: maxX, y: midY },\n      ],\n    },\n    {\n      type: 'Z',\n      points: [],\n    },\n  ];\n};\n", "import { type IPoint } from '../type';\nimport { distance } from './geo_point';\n\n/**\n * get point of line p1-p2 which is closest of p\n */\nexport const closestPtOnLine = (\n  p1: IPoint,\n  p2: IPoint,\n  p: IPoint,\n  canOutside = true,\n) => {\n  if (p1.x === p2.x && p1.y === p2.y) {\n    return {\n      t: 0,\n      point: { x: p1.x, y: p1.y },\n    };\n  }\n  const dx = p2.x - p1.x;\n  const dy = p2.y - p1.y;\n  let t = ((p.x - p1.x) * dx + (p.y - p1.y) * dy) / (dx * dx + dy * dy);\n  if (!canOutside) {\n    t = Math.max(0, Math.min(1, t));\n  }\n  const closestPt = {\n    x: p1.x + t * dx,\n    y: p1.y + t * dy,\n  };\n  return {\n    t,\n    point: closestPt,\n  };\n};\n\n/**\n * get closest point of polar coords. 0, 45, 90, 135, 150\n */\nexport const getPolarTrackSnapPt = (center: IPoint, p: IPoint, count = 4) => {\n  let closestPt: IPoint = { x: 0, y: 0 };\n  let closestDist = Infinity;\n  for (let i = 1; i <= count; i++) {\n    const rad = (Math.PI / count) * i;\n    const pt = {\n      x: center.x + Math.cos(rad),\n      y: center.y + Math.sin(rad),\n    };\n    const { point } = closestPtOnLine(center, pt, p);\n    const dist = distance(point, p);\n    if (dist === 0) {\n      return point;\n    }\n    if (dist < closestDist) {\n      closestDist = dist;\n      closestPt = point;\n    }\n  }\n  return closestPt;\n};\n\n/** get intersection of two lines */\nexport const getLineIntersection = (\n  p1: IPoint,\n  p2: IPoint,\n  p3: IPoint,\n  p4: IPoint,\n): IPoint | null => {\n  const { x: x1, y: y1 } = p1;\n  const { x: x2, y: y2 } = p2;\n  const { x: x3, y: y3 } = p3;\n  const { x: x4, y: y4 } = p4;\n\n  const a = y2 - y1;\n  const b = x1 - x2;\n  const c = x1 * y2 - x2 * y1;\n\n  const d = y4 - y3;\n  const e = x3 - x4;\n  const f = x3 * y4 - x4 * y3;\n\n  const denominator = a * e - b * d;\n\n  if (Math.abs(denominator) < 0.000000001) {\n    return null;\n  }\n\n  const px = (c * e - f * b) / denominator;\n  const py = (a * f - c * d) / denominator;\n\n  return { x: px, y: py };\n};\n", "import fitCurve from 'fit-curve';\n\nimport { type IPathItem, type ISegment } from '../type';\nimport { getBezierPoint, splitBezierSegs } from './geo_bezier';\nimport {\n  distance,\n  isZeroPoint,\n  normalizeVec,\n  pointAdd,\n  pointSub,\n} from './geo_point';\n\nexport const simplePath = (segs: ISegment[], tol: number) => {\n  const curves = fitCurve(\n    segs.map(({ point }) => [point.x, point.y]),\n    tol,\n  );\n  const newSegs: ISegment[] = [];\n  for (let i = 0, len = curves.length; i <= len; i++) {\n    const curve = curves[i];\n    const prevCurve = curves[i - 1];\n    const point = curve\n      ? {\n          x: curve[0][0],\n          y: curve[0][1],\n        }\n      : {\n          x: prevCurve[3][0],\n          y: prevCurve[3][1],\n        };\n    const outPt = curve\n      ? {\n          x: curve[1][0] - point.x,\n          y: curve[1][1] - point.y,\n        }\n      : { x: 0, y: 0 };\n    const inPt = prevCurve\n      ? {\n          x: prevCurve[2][0] - point.x,\n          y: prevCurve[2][1] - point.y,\n        }\n      : { x: 0, y: 0 };\n    newSegs.push({\n      point,\n      in: inPt,\n      out: outPt,\n    });\n  }\n  return newSegs;\n};\n\nexport const insertPathSeg = (\n  pathItem: IPathItem,\n  leftIndex: number,\n  t: number,\n) => {\n  const segs = pathItem.segs;\n\n  const isOutRangeAndNoClose =\n    !pathItem.closed && (leftIndex < 0 || leftIndex >= segs.length - 1);\n\n  if (isOutRangeAndNoClose) {\n    segs.splice(leftIndex, 1);\n    return pathItem;\n  }\n\n  let rightIndex = leftIndex + 1;\n  if (pathItem.closed) {\n    rightIndex %= segs.length;\n  }\n\n  const leftSeg = segs[leftIndex];\n  const rightSeg = segs[rightIndex];\n\n  const newSegs = splitBezierSegs(leftSeg, rightSeg, t);\n  if (rightIndex === 0) {\n    pathItem.segs.splice(leftIndex, 1, newSegs[0], newSegs[1]);\n    pathItem.segs.splice(0, 1, newSegs[2]);\n  } else {\n    pathItem.segs.splice(leftIndex, 2, ...newSegs);\n  }\n  return pathItem;\n};\n\nexport const deletePathSegAndHeal = (\n  pathItem: IPathItem,\n  targetIndex: number,\n) => {\n  const segs = pathItem.segs;\n  if (segs.length <= 1) {\n    pathItem.segs = [];\n    return pathItem;\n  }\n\n  const isOutRangeAndNoClose =\n    !pathItem.closed && (targetIndex <= 0 || targetIndex >= segs.length - 1);\n\n  if (isOutRangeAndNoClose) {\n    segs.splice(targetIndex, 1);\n    return pathItem;\n  }\n\n  let leftSegIndex = targetIndex - 1;\n  let rightSegIndex = targetIndex + 1;\n  if (pathItem.closed) {\n    leftSegIndex %= segs.length;\n    rightSegIndex %= segs.length;\n  }\n\n  const midSeg = segs[targetIndex];\n  const leftSeg = segs[leftSegIndex];\n  const rightSeg = segs[rightSegIndex];\n\n  const isNoCurve =\n    isZeroPoint(leftSeg.out) &&\n    isZeroPoint(rightSeg.in) &&\n    isZeroPoint(midSeg.in) &&\n    isZeroPoint(midSeg.out);\n  if (isNoCurve) {\n    segs.splice(targetIndex, 1);\n    return pathItem;\n  }\n\n  const leftBezier = [\n    leftSeg.point,\n    pointAdd(leftSeg.out, leftSeg.point),\n    pointAdd(midSeg.in, midSeg.point),\n    midSeg.point,\n  ];\n  const rightBezier = [\n    midSeg.point,\n    pointAdd(midSeg.out, midSeg.point),\n    pointAdd(rightSeg.in, rightSeg.point),\n    rightSeg.point,\n  ];\n\n  const leftPoints = [\n    getBezierPoint(leftBezier, 0.3),\n    getBezierPoint(leftBezier, 0.6),\n  ];\n\n  const rightPoints = [\n    getBezierPoint(rightBezier, 0.3),\n    getBezierPoint(rightBezier, 0.6),\n  ];\n\n  const curve = fitCurve(\n    [\n      leftSeg.point,\n      ...leftPoints,\n      midSeg.point,\n      ...rightPoints,\n      rightSeg.point,\n    ].map(({ x, y }) => [x, y]),\n    9999,\n  )[0];\n\n  const handle1 = pointSub(\n    {\n      x: curve[1][0],\n      y: curve[1][1],\n    },\n    leftSeg.point,\n  );\n  const handle2 = pointSub(\n    {\n      x: curve[2][0],\n      y: curve[2][1],\n    },\n    rightSeg.point,\n  );\n\n  let leftOutDir = normalizeVec(leftSeg.out);\n  if (Number.isNaN(leftOutDir.x) || Number.isNaN(leftOutDir.y)) {\n    leftOutDir = normalizeVec(handle1);\n  }\n\n  let rightInDir = normalizeVec(rightSeg.in);\n  if (Number.isNaN(rightInDir.x) || Number.isNaN(rightInDir.y)) {\n    rightInDir = normalizeVec(handle2);\n  }\n\n  const newLeftOutLen = distance({ x: 0, y: 0 }, handle1);\n  const newRightInLen = distance({ x: 0, y: 0 }, handle2);\n\n  leftSeg.out = {\n    x: leftOutDir.x * newLeftOutLen,\n    y: leftOutDir.y * newLeftOutLen,\n  };\n  rightSeg.in = {\n    x: rightInDir.x * newRightInLen,\n    y: rightInDir.y * newRightInLen,\n  };\n\n  segs.splice(targetIndex, 1);\n  return pathItem;\n};\n", "import { type IBox, type IPoint } from '../type';\nimport { getPointsBbox, isPointInBox } from './geo_box';\nimport { distance } from './geo_point';\n\ntype IBezierPoints = [IPoint, IPoint, IPoint, IPoint];\n\n/**\n * cubic bezier\n */\nexport class GeoBezier {\n  private points: IBezierPoints;\n  private dpoints: IPoint[] = []; // control points of derivative\n  private _bbox: IBox | null = null;\n  private lut: { t: number; pt: IPoint }[] = []; // lookup table\n\n  constructor(points: IBezierPoints) {\n    this.points = points;\n\n    this.dpoints[0] = {\n      x: 3 * (points[1].x - points[0].x),\n      y: 3 * (points[1].y - points[0].y),\n    };\n    this.dpoints[1] = {\n      x: 3 * (points[2].x - points[1].x),\n      y: 3 * (points[2].y - points[1].y),\n    };\n    this.dpoints[2] = {\n      x: 3 * (points[3].x - points[2].x),\n      y: 3 * (points[3].y - points[2].y),\n    };\n  }\n\n  compute(t: number) {\n    const t2 = t * t;\n    const ct = 1 - t;\n    const ct2 = ct * ct;\n    const a = ct2 * ct;\n    const b = 3 * t * ct2;\n    const c = 3 * t2 * ct;\n    const d = t2 * t;\n\n    const [p1, cp1, cp2, p2] = this.points;\n\n    return {\n      x: a * p1.x + b * cp1.x + c * cp2.x + d * p2.x,\n      y: a * p1.y + b * cp1.y + c * cp2.y + d * p2.y,\n    };\n  }\n\n  extrema() {\n    const dpoints = this.dpoints;\n    const extrema = [\n      ...getRoot(dpoints[0].x, dpoints[1].x, dpoints[2].x),\n      ...getRoot(dpoints[0].y, dpoints[1].y, dpoints[2].y),\n    ].filter((t) => t >= 0 && t <= 1);\n    return Array.from(new Set(extrema));\n  }\n\n  getBbox() {\n    if (!this._bbox) {\n      const extremaPoints = this.extrema().map((t) => this.compute(t));\n      this._bbox = getPointsBbox([\n        ...extremaPoints,\n        this.points[0],\n        this.points[3],\n      ]);\n    }\n    return this._bbox;\n  }\n\n  hitTest(point: IPoint, tol: number): boolean {\n    if (!isPointInBox(this.getBbox(), point, tol)) {\n      return false;\n    }\n\n    // based on the modification of \"project algorithm\"\n    const lookupTable = this.getLookupTable();\n\n    let minDist = Number.MAX_SAFE_INTEGER;\n    let minIndex = -1;\n\n    for (let i = 0; i < lookupTable.length; i++) {\n      const item = lookupTable[i];\n      const dist = distance(point, item.pt); // TODO: optimize, no sqrt\n      if (dist <= tol) {\n        return true;\n      }\n      if (dist < minDist) {\n        minDist = dist;\n        minIndex = i;\n      }\n    }\n\n    const minT = lookupTable[minIndex].t;\n\n    const t1 = minIndex > 0 ? lookupTable[minIndex - 1].t : minT;\n    const t2 =\n      minIndex < lookupTable.length - 1 ? lookupTable[minIndex + 1].t : minT;\n\n    const step = 0.001;\n    for (let t = t1; t <= t2; t += step) {\n      const pt = this.compute(t);\n      const dist = distance(point, pt); // TODO: optimize, no sqrt\n      if (dist <= tol) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  getLookupTable() {\n    if (this.lut.length === 0) {\n      const count = 100;\n      for (let i = 0; i <= count; i++) {\n        const t = i / count;\n        const pt = this.compute(t);\n        this.lut[i] = { t, pt };\n      }\n    }\n    return this.lut;\n  }\n\n  project(targetPt: IPoint) {\n    const lookupTable = this.getLookupTable();\n\n    let minDist = Number.MAX_SAFE_INTEGER;\n    let minIndex = -1;\n\n    for (let i = 0; i < lookupTable.length; i++) {\n      const item = lookupTable[i];\n      const dist = distance(targetPt, item.pt); // TODO: optimize, no sqrt\n      if (dist < minDist) {\n        minDist = dist;\n        minIndex = i;\n        if (dist === 0) {\n          break;\n        }\n      }\n    }\n\n    if (minDist === 0) {\n      const projectPt = this.compute(lookupTable[minIndex].t);\n      return {\n        point: projectPt,\n        t: lookupTable[minIndex].t,\n        dist: distance(targetPt, projectPt),\n      };\n    }\n\n    let minT = lookupTable[minIndex].t;\n\n    const t1 = minIndex > 0 ? lookupTable[minIndex - 1].t : minT;\n    const t2 =\n      minIndex < lookupTable.length - 1 ? lookupTable[minIndex + 1].t : minT;\n\n    const step = 0.001;\n    for (let t = t1; t <= t2; t += step) {\n      const pt = this.compute(t);\n      const dist = distance(targetPt, pt); // TODO: optimize, no sqrt\n      if (dist < minDist) {\n        minDist = dist;\n        minT = t;\n        if (dist === 0) {\n          break;\n        }\n      }\n    }\n\n    if (minT < 0) {\n      minT = 0;\n    }\n    if (minT > 1) {\n      minT = 1;\n    }\n\n    const projectPt = this.compute(minT);\n    return {\n      point: projectPt,\n      t: minT,\n      dist: distance(targetPt, projectPt),\n    };\n  }\n\n  toCommand() {\n    const [p1, cp1, cp2, p2] = this.points;\n    if (p1.x === cp1.x && cp1.x === cp2.x && cp2.x === p2.x) {\n      return [\n        { type: 'M', points: [p1] },\n        { type: 'C', points: [cp1, cp2, p2] },\n      ];\n    } else {\n      return [\n        { type: 'M', points: [p1] },\n        { type: 'C', points: [cp1, cp2, p2] },\n      ];\n    }\n  }\n}\n\nconst getRoot = (a: number, b: number, c: number) => {\n  // denominator\n  const d = a - 2 * b + c;\n\n  if (d !== 0) {\n    // quadratic equation\n    const deltaSquare = b * b - a * c;\n    if (deltaSquare < 0) {\n      // no real roots\n      return [];\n    }\n    const delta = Math.sqrt(deltaSquare);\n    const m = a - b;\n    if (delta === 0) {\n      // one real root\n      return [(m - delta) / d];\n    } else {\n      // two distinct roots\n      return [(m - delta) / d, (m + delta) / d];\n    }\n  } else if (a !== b) {\n    // linear equation\n    return [a / (a - b) / 2];\n  } else {\n    // no equation\n    return [];\n  }\n};\n", "import {\n  type IPathCommand,\n  type IPathItem,\n  type IPoint,\n  type ISegment,\n} from '../type';\nimport { GeoBezier } from './geo_bezier_class';\nimport { pointAdd } from './geo_point';\n\ninterface IBezierCurves {\n  isClosed: boolean;\n  curves: GeoBezier[];\n}\n\n/**\n * Path geometry algorithm\n */\nexport class GeoPath {\n  private bezierLists: IBezierCurves[];\n\n  constructor(pathData: IPathItem[]) {\n    const bezierItems: IBezierCurves[] = [];\n    for (let i = 0; i < pathData.length; i++) {\n      const pathItem = pathData[i];\n      const segs = pathItem.segs;\n      bezierItems[i] = {\n        isClosed: pathItem.closed,\n        curves: [],\n      };\n      for (let j = 1; j <= segs.length; j++) {\n        if (j === segs.length && !pathItem.closed) {\n          continue;\n        }\n        const seg = segs[j % segs.length];\n        const prevSeg = segs[j - 1];\n        bezierItems[i].curves.push(\n          new GeoBezier([\n            prevSeg.point,\n            GeoPath.getHandleOut(prevSeg),\n            GeoPath.getHandleIn(seg),\n            seg.point,\n          ]),\n        );\n      }\n    }\n    this.bezierLists = bezierItems;\n  }\n\n  static getHandleIn(seg: ISegment) {\n    return pointAdd(seg.point, seg.in);\n  }\n\n  static getHandleOut(seg: ISegment) {\n    return pointAdd(seg.point, seg.out);\n  }\n\n  getBbox() {\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n\n    for (const { curves } of this.bezierLists) {\n      for (const bezier of curves) {\n        const bbox = bezier.getBbox();\n        minX = Math.min(minX, bbox.minX);\n        minY = Math.min(minY, bbox.minY);\n        maxX = Math.max(maxX, bbox.maxX);\n        maxY = Math.max(maxY, bbox.maxY);\n      }\n    }\n\n    return {\n      minX,\n      minY,\n      maxX,\n      maxY,\n    };\n  }\n\n  getBRect() {\n    const bbox = this.getBbox();\n\n    if (bbox.minX === Infinity) {\n      return { x: 0, y: 0, width: 100, height: 100 };\n    }\n    return {\n      x: bbox.minX,\n      y: bbox.minY,\n      width: bbox.maxX - bbox.minX,\n      height: bbox.maxY - bbox.minY,\n    };\n  }\n\n  hitTest(point: IPoint, tol: number) {\n    for (const { curves } of this.bezierLists) {\n      for (const bezier of curves) {\n        if (bezier.hitTest(point, tol)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  project(point: IPoint, tol = Infinity) {\n    const result = {\n      dist: tol,\n      point: { x: 0, y: 0 },\n      index: [-1, -1],\n      t: -1,\n    };\n\n    for (let i = 0; i < this.bezierLists.length; i++) {\n      const { curves } = this.bezierLists[i];\n      for (let j = 0; j < curves.length; j++) {\n        const bezier = curves[j];\n        const projectInfo = bezier.project(point);\n        if (projectInfo.dist < result.dist) {\n          result.dist = projectInfo.dist;\n          result.point = projectInfo.point;\n          result.index = [i, j];\n          result.t = projectInfo.t;\n        }\n        if (projectInfo.dist === 0) {\n          break;\n        }\n      }\n    }\n    if (result.index[0] === -1) {\n      return null;\n    }\n    return result;\n  }\n\n  toCommands(): IPathCommand[] {\n    const retCmds: IPathCommand[] = [];\n    for (const { isClosed, curves } of this.bezierLists) {\n      for (let i = 0; i < curves.length; i++) {\n        const bezier = curves[i];\n        const cmd = bezier.toCommand();\n        if (i === 0) {\n          retCmds.push(...cmd);\n        } else {\n          retCmds.push(...cmd.slice(1));\n        }\n      }\n      if (isClosed) {\n        retCmds.push({\n          type: 'Z',\n          points: [],\n        });\n      }\n    }\n    return retCmds;\n  }\n}\n\nexport const commandsToStr = (commands: IPathCommand[], precision: number) => {\n  return commands\n    .map(\n      (cmd) =>\n        cmd.type +\n        cmd.points\n          .map(\n            (pt) =>\n              remainDecimal(pt.x, precision) +\n              ' ' +\n              remainDecimal(pt.y, precision),\n          )\n          .join(' '),\n    )\n    .join(' ');\n};\n\nconst remainDecimal = (num: number, precision = 2) => {\n  return Number(num.toFixed(precision));\n};\n", "import { type IPoint } from '../type';\nimport { Matrix } from './geo_matrix_class';\n\n/** arc to cubic bezier */\nexport const arcToBezier = ({\n  center,\n  r,\n  startAngle,\n  endAngle,\n  angleDir = true,\n}: {\n  center: IPoint;\n  r: number;\n  startAngle: number;\n  endAngle: number;\n  angleDir: boolean;\n}) => {\n  if (angleDir === false) {\n    [startAngle, endAngle] = [endAngle, startAngle];\n  }\n\n  const sweepAngle = (endAngle - startAngle + Math.PI * 2) % (Math.PI * 2);\n  const halfSweepAngle = sweepAngle / 2;\n  const k =\n    (4 * (1 - Math.cos(halfSweepAngle))) / (3 * Math.sin(halfSweepAngle));\n\n  const matrix = new Matrix()\n    .rotate(startAngle)\n    .scale(r, r)\n    .translate(center.x, center.y);\n\n  endAngle -= startAngle;\n  startAngle = 0;\n\n  const p1 = matrix.apply({\n    x: 1,\n    y: 0,\n  });\n  const p2 = matrix.apply({\n    x: 1,\n    y: k,\n  });\n\n  const p3 = matrix.apply({\n    x: Math.cos(sweepAngle) + k * Math.sin(sweepAngle),\n    y: Math.sin(sweepAngle) - k * Math.cos(sweepAngle),\n  });\n\n  const p4 = matrix.apply({\n    x: Math.cos(sweepAngle),\n    y: Math.sin(sweepAngle),\n  });\n\n  if (angleDir) {\n    return [p1, p2, p3, p4];\n  }\n  return [p4, p3, p2, p1];\n};\n", "import { type IPathCommand, type IPoint, type ISize } from '../type';\nimport { getAngleBetweenVec, getSweepAngle } from './geo_angle';\nimport { arcToBezier } from './geo_arc';\nimport { closestPtOnLine, getLineIntersection } from './geo_line';\nimport { Matrix } from './geo_matrix_class';\nimport { distance, isPointEqual, lerpNum, pointMid } from './geo_point';\n\nexport const getRegularPolygon = (size: ISize, count: number): IPoint[] => {\n  const cx = size.width / 2;\n  const cy = size.height / 2;\n\n  const points: IPoint[] = [{ x: cx, y: 0 }];\n  const rad = (Math.PI * 2) / count;\n  const rotateTf = new Matrix()\n    .translate(-cx, -cy)\n    .rotate(rad)\n    .translate(cx, cy);\n  let prevPoint = points[0];\n  for (let i = 1; i < count; i++) {\n    const { x, y } = rotateTf.apply(prevPoint);\n    const pt = { x, y };\n    points.push(pt);\n    prevPoint = pt;\n  }\n\n  // \u4E24\u4FA7\u5411\u4E2D\u5782\u7EBF\u584C\u9677\n  const t = size.width / size.height;\n  for (let i = 1; i < count; i++) {\n    const pt = points[i];\n    pt.x = lerpNum(cx, pt.x, t);\n  }\n\n  return points;\n};\n\nexport const isPointInConvexPolygon = (polygon: IPoint[], point: IPoint) => {\n  let dir: number | undefined = undefined;\n  for (let i = 0; i < polygon.length; i++) {\n    const start = polygon[i];\n    const end = polygon[(i + 1) % polygon.length];\n    const a = {\n      x: end.x - start.x,\n      y: end.y - start.y,\n    };\n    const b = {\n      x: point.x - start.x,\n      y: point.y - start.y,\n    };\n    const currDir = Math.sign(a.x * b.y - a.y * b.x);\n    if (currDir === 0) {\n      continue;\n    }\n    if (dir === undefined) {\n      dir = currDir;\n    } else if (dir !== currDir) {\n      return false;\n    }\n  }\n  return true;\n};\n\nexport const isPointInPolygon = (polygon: IPoint[], pt: IPoint): boolean => {\n  let isIn = false;\n  for (let i = 0; i < polygon.length; i++) {\n    let a = polygon[i];\n    let b = polygon[(i + 1) % polygon.length];\n\n    if (a.y > b.y) {\n      [a, b] = [b, a];\n    }\n\n    if (a.y <= pt.y && b.y > pt.y) {\n      const crossProduct =\n        (pt.x - a.x) * (b.y - a.y) - (b.x - a.x) * (pt.y - a.y);\n      if (crossProduct === 0) {\n        return true;\n      } else if (crossProduct > 0) {\n        isIn = !isIn;\n      }\n    }\n  }\n\n  return isIn;\n};\n\nexport const roundPolygon = (polygon: IPoint[], radius: number) => {\n  const path: IPathCommand[] = [];\n  for (let i = 0; i < polygon.length; i++) {\n    const p1 = polygon[(i - 1 + polygon.length) % polygon.length];\n    const p2 = polygon[i];\n    const p3 = polygon[(i + 1) % polygon.length];\n\n    const r = getCorrectedRadius(\n      pointMid(p1, p2),\n      p2,\n      pointMid(p2, p3),\n      radius,\n    );\n\n    const arc = getLineJointRoundArc([p1, p2], [p2, p3], r)!;\n\n    if (i === 0) {\n      path.push({\n        type: 'M',\n        points: [arc.start],\n      });\n    } else {\n      const lastCmdPoints = path[path.length - 1].points;\n      const lastAnchorPoint = lastCmdPoints[lastCmdPoints.length - 1];\n      if (!isPointEqual(arc.start, lastAnchorPoint)) {\n        path.push({\n          type: 'L',\n          points: [arc.start],\n        });\n      }\n    }\n\n    const pathCmds = arcToBezier({\n      center: arc.center,\n      r,\n      startAngle: arc.startAngle,\n      endAngle: arc.endAngle,\n      angleDir: arc.angleDir,\n    });\n\n    path.push({\n      type: 'C',\n      points: [pathCmds[1], pathCmds[2], pathCmds[3]],\n    });\n  }\n  path.push({\n    type: 'Z',\n    points: [],\n  });\n  return path;\n};\n\nconst getCorrectedRadius = (\n  p1: IPoint,\n  p2: IPoint,\n  p3: IPoint,\n  radius: number,\n) => {\n  const v1 = {\n    x: p2.x - p1.x,\n    y: p2.y - p1.y,\n  };\n  const v2 = {\n    x: p2.x - p3.x,\n    y: p2.y - p3.y,\n  };\n  const angle = getAngleBetweenVec(v1, v2) / 2;\n\n  const r1 = Math.tan(angle) * distance(p1, p2);\n  const r2 = Math.tan(angle) * distance(p2, p3);\n  return Math.min(radius, r1, r2);\n};\n\nexport const getLineJointRoundArc = (\n  line1: IPoint[],\n  line2: IPoint[],\n  radius: number,\n) => {\n  const p1 = line1[0];\n  const p2 = line1[1];\n  const p3 = line2[0];\n  const p4 = line2[1];\n\n  const v1 = {\n    x: p1.x - p2.x,\n    y: p1.y - p2.y,\n  };\n\n  const v2 = {\n    x: p4.x - p3.x,\n    y: p4.y - p3.y,\n  };\n\n  const cp = v1.x * v2.y - v2.x * v1.y;\n  if (cp === 0) {\n    return null;\n  }\n  let normalVec1: IPoint;\n  let normalVec2: IPoint;\n  if (cp < 0) {\n    normalVec1 = {\n      x: v1.y,\n      y: -v1.x,\n    };\n    normalVec2 = {\n      x: -v2.y,\n      y: v2.x,\n    };\n  } else {\n    normalVec1 = {\n      x: -v1.y,\n      y: v1.x,\n    };\n    normalVec2 = {\n      x: v2.y,\n      y: -v2.x,\n    };\n  }\n\n  const t1 = radius / distance(p1, p2);\n  const d = {\n    x: normalVec1.x * t1,\n    y: normalVec1.y * t1,\n  };\n  const offsetLine1 = [\n    {\n      x: p1.x + d.x,\n      y: p1.y + d.y,\n    },\n    {\n      x: p2.x + d.x,\n      y: p2.y + d.y,\n    },\n  ];\n\n  const t2 = radius / distance(p3, p4);\n  const d2 = {\n    x: normalVec2.x * t2,\n    y: normalVec2.y * t2,\n  };\n  const offsetLine2 = [\n    {\n      x: p3.x + d2.x,\n      y: p3.y + d2.y,\n    },\n    {\n      x: p4.x + d2.x,\n      y: p4.y + d2.y,\n    },\n  ];\n\n  const center = getLineIntersection(\n    offsetLine1[0],\n    offsetLine1[1],\n    offsetLine2[0],\n    offsetLine2[1],\n  )!;\n\n  const { point: start } = closestPtOnLine(p1, p2, center, true);\n  const { point: end } = closestPtOnLine(p3, p4, center, true);\n\n  const angleBase = { x: 1, y: 0 };\n  const startAngle = getSweepAngle(angleBase, {\n    x: start.x - center.x,\n    y: start.y - center.y,\n  });\n  const endAngle = getSweepAngle(angleBase, {\n    x: end.x - center.x,\n    y: end.y - center.y,\n  });\n\n  return {\n    center,\n    start,\n    end,\n    startAngle,\n    endAngle,\n    angleDir: cp < 0, // positive --> clockwise\n  };\n};\n", "import { type IPoint, type ITransformRect } from '../type';\nimport { getSweepAngle } from './geo_angle';\nimport { getPolarTrackSnapPt } from './geo_line';\nimport { Matrix } from './geo_matrix_class';\nimport { distance } from './geo_point';\n\n/**\n * Get the new position of the line when resizing\n * we consider the graphics with 0 height as a line\n *\n * TODO: reuse, this is something same code in tool_draw_graph.ts\n */\nexport const resizeLine = (\n  /** control type, 'se' | 'ne' | 'nw' | 'sw' */\n  type: string,\n  newPos: IPoint,\n  rect: ITransformRect,\n  options: {\n    /** keep rotation in 0 45 90 ... */\n    keepPolarSnap?: boolean;\n    scaleFromCenter?: boolean;\n  } = {\n    keepPolarSnap: false,\n    scaleFromCenter: false,\n  },\n): ITransformRect => {\n  if (!['se', 'ne', 'nw', 'sw'].includes(type)) {\n    throw new Error(`invalid type \"${type}\"`);\n  }\n\n  const isRightControl = type === 'se' || type === 'ne';\n\n  let globalOrigin: IPoint = { x: 0, y: 0 };\n  if (options.scaleFromCenter) {\n    globalOrigin = new Matrix(...rect.transform).apply({\n      x: rect.width / 2,\n      y: rect.height / 2,\n    });\n  } else if (isRightControl) {\n    globalOrigin = {\n      x: rect.transform[4],\n      y: rect.transform[5],\n    };\n  } else {\n    globalOrigin = new Matrix(...rect.transform).apply({\n      x: rect.width,\n      y: rect.height,\n    });\n  }\n\n  if (options.keepPolarSnap) {\n    newPos = getPolarTrackSnapPt(globalOrigin, newPos);\n  }\n\n  let width = distance(newPos, globalOrigin);\n  if (options.scaleFromCenter) {\n    width *= 2;\n  }\n\n  if (isRightControl) {\n    const offset = {\n      x: newPos.x - globalOrigin.x,\n      y: newPos.y - globalOrigin.y,\n    };\n    const rotate = getSweepAngle(\n      { x: 1, y: 0 },\n      {\n        x: newPos.x - globalOrigin.x,\n        y: newPos.y - globalOrigin.y,\n      },\n    );\n    const tf = new Matrix()\n      .rotate(rotate)\n      .translate(globalOrigin.x, globalOrigin.y);\n\n    if (options.scaleFromCenter) {\n      tf.translate(-offset.x, -offset.y);\n    }\n\n    return {\n      width,\n      height: 0,\n      transform: tf.getArray(),\n    };\n  } else {\n    const offset = {\n      x: globalOrigin.x - newPos.x,\n      y: globalOrigin.y - newPos.y,\n    };\n    const rotate = getSweepAngle({ x: 1, y: 0 }, offset);\n\n    const tf = new Matrix().rotate(rotate);\n    const newRightBottom = tf.apply({ x: width, y: rect.height });\n    tf.translate(\n      globalOrigin.x - newRightBottom.x,\n      globalOrigin.y - newRightBottom.y,\n    );\n\n    if (options.scaleFromCenter) {\n      tf.translate(offset.x, offset.y);\n    }\n\n    return {\n      width,\n      height: 0,\n      transform: tf.getArray(),\n    };\n  }\n};\n", "import { type IPoint, type ITransformRect } from '../../type';\nimport { Matrix } from '../geo_matrix_class';\n\ninterface IResizeOp {\n  getLocalOrigin(width: number, height: number): IPoint;\n  getNewSize(\n    newLocalPt: IPoint,\n    localOrigin: IPoint,\n    rect: { width: number; height: number },\n  ): {\n    width: number;\n    height: number;\n  };\n  /**\n   * \u4FDD\u6301\u7F29\u653E\u6BD4\u4F8B\u65F6\uFF0C\u662F\u57FA\u4E8E width \u8FD8\u662F height \u53BB\u8BA1\u7B97\u65B0\u7684 width height\n   */\n  isBaseWidthWhenKeepRatio(isWidthLarger: boolean): boolean;\n  /**\n   * \u57FA\u4E8E\u4E2D\u5FC3\u7F29\u653E\u65F6\uFF0C\u5BF9 size \u8FDB\u884C\u4FEE\u6B63\n   */\n  getSizeWhenScaleFromCenter(\n    width: number,\n    height: number,\n  ): { width: number; height: number };\n}\n\nconst doubleSize = (width: number, height: number) => ({\n  width: width * 2,\n  height: height * 2,\n});\n\nconst resizeOps: Record<string, IResizeOp> = {\n  sw: {\n    getLocalOrigin: (width: number) => ({ x: width, y: 0 }),\n    getNewSize: (newLocalPt: IPoint, localOrigin: IPoint) => ({\n      width: localOrigin.x - newLocalPt.x,\n      height: newLocalPt.y - localOrigin.y,\n    }),\n    isBaseWidthWhenKeepRatio: (isWidthLarger: boolean) => isWidthLarger,\n    getSizeWhenScaleFromCenter: doubleSize,\n  },\n  se: {\n    getLocalOrigin: () => ({ x: 0, y: 0 }),\n    getNewSize: (newLocalPt, localOrigin) => ({\n      width: newLocalPt.x - localOrigin.x,\n      height: newLocalPt.y - localOrigin.y,\n    }),\n    isBaseWidthWhenKeepRatio: (isWidthLarger: boolean) => isWidthLarger,\n    getSizeWhenScaleFromCenter: doubleSize,\n  },\n  nw: {\n    getLocalOrigin: (width, height) => {\n      return { x: width, y: height };\n    },\n    getNewSize: (newLocalPt, localOrigin) => {\n      return {\n        width: localOrigin.x - newLocalPt.x,\n        height: localOrigin.y - newLocalPt.y,\n      };\n    },\n    isBaseWidthWhenKeepRatio: (isWidthLarger: boolean) => isWidthLarger,\n    getSizeWhenScaleFromCenter: doubleSize,\n  },\n  ne: {\n    getLocalOrigin: (_width, height) => ({ x: 0, y: height }),\n    getNewSize: (newLocalPt, localOrigin) => ({\n      width: newLocalPt.x - localOrigin.x,\n      height: localOrigin.y - newLocalPt.y,\n    }),\n    isBaseWidthWhenKeepRatio: (isWidthLarger: boolean) => isWidthLarger,\n    getSizeWhenScaleFromCenter: doubleSize,\n  },\n  n: {\n    getLocalOrigin: (width, height) => ({ x: width / 2, y: height }),\n    getNewSize: (newLocalPt, localOrigin, rect) => ({\n      width: rect.width,\n      height: localOrigin.y - newLocalPt.y,\n    }),\n    isBaseWidthWhenKeepRatio: () => false,\n    getSizeWhenScaleFromCenter: (width, height) => ({\n      width: width,\n      height: height * 2,\n    }),\n  },\n  s: {\n    getLocalOrigin: (width) => ({ x: width / 2, y: 0 }),\n    getNewSize: (newLocalPt, localOrigin, rect) => ({\n      width: rect.width,\n      height: newLocalPt.y - localOrigin.y,\n    }),\n    isBaseWidthWhenKeepRatio: () => false,\n    getSizeWhenScaleFromCenter: (width, height) => ({\n      width: width,\n      height: height * 2,\n    }),\n  },\n  e: {\n    getLocalOrigin: (_width, height) => ({ x: 0, y: height / 2 }),\n    getNewSize: (newLocalPt, localOrigin, rect) => ({\n      width: newLocalPt.x - localOrigin.x,\n      height: rect.height,\n    }),\n    isBaseWidthWhenKeepRatio: () => true,\n    getSizeWhenScaleFromCenter: (width, height) => ({\n      width: width * 2,\n      height: height,\n    }),\n  },\n  w: {\n    getLocalOrigin: (width, height) => ({ x: width, y: height / 2 }),\n    getNewSize: (newLocalPt, localOrigin, rect) => ({\n      width: localOrigin.x - newLocalPt.x,\n      height: rect.height,\n    }),\n    isBaseWidthWhenKeepRatio: () => true,\n    getSizeWhenScaleFromCenter: (width, height) => ({\n      width: width * 2,\n      height: height,\n    }),\n  },\n};\n\n/**\n * get resized rect\n * used for resize operation\n */\nexport const resizeRect = (\n  /** 'se' | 'ne' | 'nw' | 'sw' | 'n' | 'e' | 's' | 'w' */\n  type: string,\n  newGlobalPt: IPoint,\n  rect: ITransformRect,\n  options?: {\n    keepRatio?: boolean;\n    scaleFromCenter?: boolean;\n    noChangeWidthAndHeight?: boolean;\n    flip?: boolean;\n  },\n): ITransformRect => {\n  const resizeOp = resizeOps[type];\n  if (!resizeOp) {\n    throw new Error(`resize type ${type} is invalid`);\n  }\n  const {\n    keepRatio,\n    scaleFromCenter,\n    noChangeWidthAndHeight,\n    flip = true,\n  } = options ?? {};\n  const transform = new Matrix(...rect.transform);\n  const newRect = {\n    width: 0,\n    height: 0,\n    transform: transform.clone(),\n  };\n\n  const localOrigin = scaleFromCenter\n    ? { x: rect.width / 2, y: rect.height / 2 }\n    : resizeOp.getLocalOrigin(rect.width, rect.height);\n\n  const newLocalPt = transform.applyInverse(newGlobalPt);\n  // FIXME: consider case when width or height is 0\n  let size = resizeOp.getNewSize(newLocalPt, localOrigin, rect);\n\n  if (scaleFromCenter) {\n    size = resizeOp.getSizeWhenScaleFromCenter(size.width, size.height);\n  }\n\n  if (keepRatio) {\n    const ratio = rect.width / rect.height;\n    const newRatio = Math.abs(size.width / size.height);\n    const isWidthLarger = newRatio > ratio;\n    if (resizeOp.isBaseWidthWhenKeepRatio(isWidthLarger)) {\n      size.height = (Math.sign(size.height) * Math.abs(size.width)) / ratio;\n    } else {\n      size.width = Math.sign(size.width) * Math.abs(size.height) * ratio;\n    }\n  }\n\n  const scaleTf = new Matrix();\n  const scaleX = Math.sign(size.width) || 1;\n  const scaleY = Math.sign(size.height) || 1;\n\n  if (noChangeWidthAndHeight) {\n    scaleTf.scale(size.width / rect.width, size.height / rect.height);\n    newRect.width = rect.width;\n    newRect.height = rect.height;\n  } else {\n    newRect.width = Math.abs(size.width);\n    newRect.height = Math.abs(size.height);\n    scaleTf.scale(scaleX, scaleY);\n  }\n\n  newRect.transform = newRect.transform.append(scaleTf);\n\n  const newGlobalOrigin = newRect.transform.apply(\n    scaleFromCenter\n      ? { x: newRect.width / 2, y: newRect.height / 2 }\n      : resizeOp.getLocalOrigin(newRect.width, newRect.height),\n  );\n  const globalOrigin = transform.apply(localOrigin);\n\n  const offset = {\n    x: globalOrigin.x - newGlobalOrigin.x,\n    y: globalOrigin.y - newGlobalOrigin.y,\n  };\n  newRect.transform.prepend(new Matrix().translate(offset.x, offset.y));\n\n  if (!flip) {\n    const flipFixedTf = new Matrix()\n      .translate(-newRect.width / 2, -newRect.height / 2)\n      .scale(scaleX, scaleY)\n      .translate(newRect.width / 2, newRect.height / 2);\n    newRect.transform.append(flipFixedTf);\n  }\n\n  return {\n    width: newRect.width,\n    height: newRect.height,\n    transform: newRect.transform.getArray(),\n  };\n};\n", "import { type IPoint, type ISize } from '../type';\nimport { Matrix } from './geo_matrix_class';\nimport { lerp, lerpNum } from './geo_point';\n\nexport const getStar = (\n  size: ISize,\n  count: number,\n  innerScale: number,\n): IPoint[] => {\n  const cx = size.width / 2;\n  const cy = size.height / 2;\n\n  const points: IPoint[] = new Array(count * 2);\n  points[0] = { x: cx, y: 0 };\n  const rad = (Math.PI * 2) / count;\n\n  // out\n  const rotateTf = new Matrix()\n    .translate(-cx, -cy)\n    .rotate(rad)\n    .translate(cx, cy);\n\n  let prevPoint = points[0];\n  for (let i = 1; i < count; i++) {\n    const { x, y } = rotateTf.apply(prevPoint);\n    const pt = { x, y };\n    points[i * 2] = pt;\n    prevPoint = pt;\n  }\n\n  // inner\n  const innerRotateTf = new Matrix()\n    .translate(-cx, -cy)\n    .rotate(rad / 2)\n    .translate(cx, cy);\n  prevPoint = lerp(\n    { x: cx, y: cy },\n    innerRotateTf.apply(points[0]),\n    innerScale,\n  );\n\n  points[1] = prevPoint;\n  for (let i = 1; i < count; i++) {\n    const { x, y } = rotateTf.apply(prevPoint);\n    const pt = { x, y };\n    points[i * 2 + 1] = pt;\n    prevPoint = pt;\n  }\n\n  const t = size.width / size.height;\n  for (let i = 1; i < points.length; i++) {\n    const pt = points[i];\n    pt.x = lerpNum(cx, pt.x, t);\n  }\n\n  return points;\n};\n", "import { type IPoint } from '../type';\n\nlet _ctx: CanvasRenderingContext2D | null = null;\n\nconst getContext = () => {\n  if (_ctx) return _ctx;\n  const canvas = document.createElement('canvas');\n  _ctx = canvas.getContext('2d')!;\n  _ctx.fontKerning = 'none'; // no kerning\n  return _ctx;\n};\n\nexport interface ITextMetrics {\n  width: number;\n  height: number;\n  fontBoundingBoxAscent: number;\n}\n\nexport interface IGlyph extends ITextMetrics {\n  position: IPoint;\n}\n\nexport interface IFontStyle {\n  fontSize: number;\n  fontFamily: string;\n}\n\nexport const calcGlyphInfos = (content: string, fontStyle: IFontStyle) => {\n  const glyphs: IGlyph[] = [];\n  const position: IPoint = { x: 0, y: 0 };\n  const ctx = getContext();\n  ctx.font = `${fontStyle.fontSize}px ${fontStyle.fontFamily}`;\n  for (const c of content) {\n    const textMetrics = ctx.measureText(c);\n    glyphs.push({\n      position: { ...position },\n      width: textMetrics.width,\n      height:\n        textMetrics.fontBoundingBoxAscent + textMetrics.fontBoundingBoxDescent,\n      fontBoundingBoxAscent: textMetrics.fontBoundingBoxAscent,\n    });\n    position.x += textMetrics.width;\n  }\n  // \u672B\u5C3E\u6362\u884C\u7B26\n  glyphs.push({\n    position: { ...position },\n    width: 0,\n    height: 0,\n    fontBoundingBoxAscent: 0,\n  });\n  return glyphs;\n};\n\nexport const calcTextSize = (\n  content: string,\n  fontStyle: IFontStyle,\n): ITextMetrics => {\n  const ctx = getContext();\n  ctx.font = `${fontStyle.fontSize}px ${fontStyle.fontFamily}`;\n  const textMetrics = ctx.measureText(content);\n  return {\n    width: textMetrics.width,\n    height:\n      textMetrics.fontBoundingBoxAscent + textMetrics.fontBoundingBoxDescent,\n    fontBoundingBoxAscent: textMetrics.fontBoundingBoxAscent,\n  };\n};\n"],
  "mappings": "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",
  "names": ["distance", "projectPt"]
}
